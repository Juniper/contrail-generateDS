#
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

from ifmap_global import CamelCase
from ifmap_model import IFMapIdentifier, IFMapProperty, IFMapLink, \
    IFMapLinkAttr, AmbiguousParentType
from TypeGenerator import TypeGenerator
from collections import OrderedDict

import importlib
import pprint
import re
import os
import sys
import json

_BASE_URL = ""
_BASE_PARENT = 'config-root'
_BASE_PARENT_IMID = 'contrail:config-root:root'

def write(gen_file, gen_str):
    gen_file.write("%s\n" %(gen_str))
# end write

class IFMapApiGenerator(object):
    def __init__(self, xsd_parser, xsd_root, ident_dict, metadata_dict):
        self._xsd_parser = xsd_parser
        self._xsd_root = xsd_root
        self._ident_dict = ident_dict
        self._metadata_dict = metadata_dict
        # [<tenant>,...]")
        self._FQ_NAME_TENANT_IDX = 0
    # end __init__

    def Generate(self, gen_filepath_pfx):
        xsd_openapi_dict = OrderedDict([])
        # Grab directory where to generate (if not locally)
        gen_filename_pfx = os.path.basename(gen_filepath_pfx)
        self._type_genr = TypeGenerator(self._xsd_parser)
        self._type_genr.setLanguage('py')
        self._type_genr.generate(self._xsd_root, None, gen_filepath_pfx + "_xsd.py",
                           genStandAlone = False, openapi_dict=xsd_openapi_dict)
        gendir = os.path.dirname(gen_filepath_pfx)
        if gendir:
           gendir = gendir + '/'

        # class defn used by both rest-api client and server
        # create a package for autogenerated code
        self._generate_package(gendir)
        # These produce classes/files per type
        self._generate_common_classes(gen_filepath_pfx)
        self._generate_client_classes(gen_filepath_pfx, gen_filename_pfx)
        self._generate_test_classes(gen_filepath_pfx, gen_filename_pfx)
        self._generate_heat_resources(gen_filepath_pfx, gen_filename_pfx)
        #self._generate_docs_classes(gen_filepath_pfx, gen_filename_pfx)

        # These produce class/file common to all types
        self._generate_conn_drv_impl(gendir + "connection_drv_gen.py", gen_filename_pfx)
        self._generate_client_impl(gendir + "vnc_api_client_gen.py", gen_filename_pfx)
        self._generate_extension_impl(gendir + "vnc_api_extension_gen.py", gen_filename_pfx)
        self._generate_test_impl(gendir + "vnc_api_test_gen.py", gen_filename_pfx)
        self._generate_docs_schema(gendir + "vnc_api_schema.py", gen_filename_pfx)
        openapi_dict = self._generate_docs_openapi(gendir + "contrail_openapi.json",
            gen_filename_pfx, xsd_openapi_dict)
        self._generate_docs_asciidoc(gendir + "contrail_openapi.adoc",
            gen_filename_pfx, openapi_dict)
        self._generate_docs_sphinx(gendir + "contrail_openapi.rst",
            gen_filename_pfx, openapi_dict)
        # With generation above, html doc can be built as:
        # asciidoctor build/debug/api-lib/vnc_api/gen/contrail_openapi.adoc \
        #             --backend html5 --doctype book -a toc=left -a toclevels=3 \
        #             -a numbered= -a sectlinks=  -a sectanchors= -a hardbreaks=
    # end Generate

    def _non_exclude_idents(self):
        _ret_idents = []
        for ident in self._ident_dict.values():
            ident_name = ident.getName()
            # TODO put Exclude on identifiers too...
            if re.match("bgp:", ident_name):
                continue
            _ret_idents.append(ident)

        return _ret_idents
    # end _non_exclude_idents

    def _generate_package(self, gendir):
        gen_file = self._xsd_parser.makeFile(gendir + "__init__.py")
    # end _generate_package

    def _generate_common_classes(self, gen_filepath_pfx):
        # XSD types to python classes
        gen_file = self._xsd_parser.makeFile(gen_filepath_pfx + "_common.py")
        write(gen_file, "")
        write(gen_file, "# AUTO-GENERATED file from %s. Do Not Edit!" \
              %(self.__class__.__name__))
        write(gen_file, "")
        write(gen_file, '"""')
        write(gen_file, "This module defines the classes for every configuration element managed by the system")
        write(gen_file, '"""')
        write(gen_file, "")
        write(gen_file, "try:")
        write(gen_file, "    from cfgm_common.exceptions import AmbiguousParentError")
        write(gen_file, "except ImportError:")
        write(gen_file, "    try:")
        write(gen_file, "        from vnc_api.exceptions import AmbiguousParentError")
        write(gen_file, "    except ImportError:")
        write(gen_file, "        pass")
        write(gen_file, "")

        for ident in self._non_exclude_idents():
            class_name = CamelCase(ident.getName())
            ident_name = ident.getName()
            method_name = ident_name.replace('-', '_')
            my_name_default = 'default-%s' %(ident.getName())
            parents = ident.getParents()

            write(gen_file, "class %s(object):" %(class_name))
            write(gen_file, '    """')

            # Document description for object
            description = ident.getElement().attrs.get('description')
            if not description:
                description = ''
                for parent_ident, parent_link, _ in ident.getParents() or []:
                    if len(ident.getParents()) > 1:
                        indent = ' '*8
                        description += ' '*4 + 'When parent is %s:\n%s' %(parent_ident.getName(), indent)
                        description += ('\n'+indent).join(parent_link.getDescription(width=100))
                        description += '\n'
                    else:
                        indent = ' '*4
                        description += indent
                        description += ('\n'+indent).join(parent_link.getDescription(width=100))

            write(gen_file, description)
            write(gen_file, "")

            # Document created-by for object
            created_by = ident.getElement().attrs.get('created-by')
            write(gen_file, "    Created By:")
            if created_by:
                write(gen_file, "        %s" %(created_by))
            elif parents and len(parents) == 1:
                (parent_ident, meta, _) = parents[0]
                if (parent_ident.getName().lower() == 'config-root' or
                    meta.getPresence().lower() != 'system-only'):
                    created_by = 'User'
                else:
                    created_by = 'System'
                write(gen_file, "        %s" %(created_by))
            else:
                for i in range(len(parents or [])):
                    (parent_ident, meta, _) = parents[i]
                    if meta.getPresence().lower() != 'system-only':
                        created_by = 'User'
                    else:
                        created_by = 'System'
                    parent_class_name = CamelCase(parent_ident.getName())
                    write(gen_file, "        %s when parent is :class:`.%s`" %(
                        created_by, parent_class_name))
            write(gen_file, "")

            # Document parents for object
            if parents:
                write(gen_file, "    Child of:")
                for i in range(len(parents)):
                    (parent_ident, meta, _) = parents[i]
                    parent_class_name = CamelCase(parent_ident.getName())
                    if i == len(parents)-1:
                        write(gen_file, "        :class:`.%s` object" %(parent_class_name))
                    else:
                        write(gen_file, "        :class:`.%s` object OR" %(parent_class_name))
                write(gen_file, "")

            write(gen_file, "    Properties:")
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                prop_xml_elem = prop.getElement()
                complex_type = prop.getCType()
                xsd_type = prop.getXsdType()
                presence = prop.getPresence()
                if presence.lower() != 'system-only':
                    # optional or required
                    created_by = 'User (%s)' %(presence)
                else:
                    created_by = 'System'
                if complex_type and xsd_type:
                    write(gen_file, "        * %s" %(prop_name))
                    write(gen_file, "            Type: :class:`.%s`\n" %(prop.getXsdType()))
                    write(gen_file, "            Created By: %s\n" %(created_by))
                    write(gen_file, "            Operations Allowed: %s\n" %(prop.getOperations()))
                    write(gen_file, "            Description:\n")
                    for desc_line in prop.getDescription(width=100):
                        write(gen_file, "              %s\n" %(desc_line))
                elif prop_xml_elem.getSchemaType() in self._xsd_parser.SimpleTypeDict:
                    # handle simple restriction
                    r_base = self._xsd_parser.SimpleTypeDict[prop_xml_elem.getSchemaType()]
                    if r_base.values and isinstance(r_base.values[0], dict): # range
                        restriction_type = '*within*'
                        restriction_values = [r_base.values[0]['minimum'],
                                              r_base.values[1]['maximum']]
                    else: # enum
                        restriction_type = '*one-of*'
                        if r_base.values:
                            restriction_values = r_base.values
                        else:
                            restriction_values = r_base.base
                    python_type = self._xsd_parser.SchemaToPythonTypeMap[r_base.base]
                    write(gen_file, "        * %s" %(prop_name))
                    write(gen_file, "            Type: %s, %s %s\n" %(
                              python_type, restriction_type, restriction_values))
                    write(gen_file, "            Created By: %s\n" %(created_by))
                    write(gen_file, "            Operations Allowed: %s\n" %(prop.getOperations()))
                    write(gen_file, "            Description:\n")
                    for desc_line in prop.getDescription(width=100):
                        write(gen_file, "              %s\n" %(desc_line))
                else:
                    python_type = self._xsd_parser.SchemaToPythonTypeMap[prop.getXsdType().lower()]
                    write(gen_file, "        * %s" %(prop_name))
                    write(gen_file, "            Type: %s\n" %(python_type))
                    write(gen_file, "            Created By: %s\n" %(created_by))
                    write(gen_file, "            Operations Allowed: %s\n" %(prop.getOperations()))
                    write(gen_file, "            Description:\n")
                    for desc_line in prop.getDescription(width=100):
                        write(gen_file, "              %s\n" %(desc_line))
            write(gen_file, "")
            write(gen_file, "    Children:")
            for link_info in ident.getLinksInfo():
                is_has = ident.isLinkHas(link_info)
                if not is_has:
                    continue
                link = ident.getLink(link_info)
                presence = link.getPresence()
                if presence.lower() != 'system-only':
                    # optional or required
                    created_by = 'User (%s)' %(presence)
                else:
                    created_by = 'System'
                child_ident = ident.getLinkTo(link_info)
                child_class_name = CamelCase(child_ident.getName())
                write(gen_file, "        * list of :class:`.%s` objects" %(child_class_name))
                write(gen_file, "            Created By: %s\n" %(created_by))
                write(gen_file, "            Operations Allowed: %s\n" %(link.getOperations()))
                write(gen_file, "            Description:\n")
                for desc_line in link.getDescription(width=100):
                    write(gen_file, "              %s\n" %(desc_line))
            write(gen_file, "")
            write(gen_file, "    References to:")
            for link_info in ident.getLinksInfo():
                link = ident.getLink(link_info)
                to_ident = ident.getLinkTo(link_info)
                to_class_name = CamelCase(to_ident.getName())
                is_ref = ident.isLinkRef(link_info)
                if not is_ref:
                    continue
                presence = link.getPresence()
                if presence.lower() != 'system-only':
                    # optional or required
                    created_by = 'User (%s)' %(presence)
                else:
                    created_by = 'System'
                link_attr_type = link.getXsdType()
                if link_attr_type: # link with attr
                    write(gen_file, "        * list of (:class:`.%s` object, :class:`.%s` attribute)" %(to_class_name, link_attr_type))
                else:
                    write(gen_file, "        * list of :class:`.%s` objects" %(to_class_name))
                write(gen_file, "            Created By: %s\n" %(created_by))
                write(gen_file, "            Operations Allowed: %s\n" %(link.getOperations()))
                write(gen_file, "            Description:\n")
                for desc_line in link.getDescription(width=100):
                    write(gen_file, "              %s\n" %(desc_line))
            write(gen_file, "")
            write(gen_file, "    Referred by:")
            for back_link_info in ident.getBackLinksInfo():
                if not ident.isLinkRef(back_link_info):
                    continue
                from_ident = ident.getBackLinkFrom(back_link_info)
                from_class_name = CamelCase(from_ident.getName())
                write(gen_file, "        * list of :class:`.%s` objects" %(from_class_name))
            write(gen_file, '    """')
            write(gen_file, "")

            write(gen_file, "    resource_type = '%s'" %(ident_name))
            write(gen_file, "    object_type = '%s'" %(ident_name.replace('-', '_')))
            write(gen_file, "")

            prop_fields = [prop.getName().replace('-', '_') for prop in ident.getProperties()]
            ref_fields = ['%s_refs' %(ref_ident.getName().replace('-', '_')) for ref_ident in ident.getReferences()]
            back_ref_fields = ['%s_back_refs' %(back_ref_ident.getName().replace('-', '_')) for back_ref_ident in ident.getBackReferences()]
            children_fields = ['%ss' %(child_ident.getName().replace('-', '_')) for child_ident in ident.getChildren()]
            write(gen_file, "    prop_fields = set(%s)" %(prop_fields))
            write(gen_file, "    ref_fields = set(%s)" %(ref_fields))
            write(gen_file, "    backref_fields = set(%s)" %(back_ref_fields))
            write(gen_file, "    children_fields = set(%s)" %(children_fields))
            write(gen_file, "")
            prop_field_types = []
            for prop in ident.getProperties():
                name = prop.getName().replace('-', '_')
                is_complex = prop.getCType() is not None
                simple_type = prop.getElement().getSimpleType()
                prop_type = prop.getElement().getType()
                xsd_type = prop_type.replace('xsd:', '')
                restrictions = None
                restriction_type = None
                if simple_type:
                    restrict_values = self._xsd_parser.SimpleTypeDict[simple_type].values
                    if restrict_values and isinstance(restrict_values[0], dict):
                        restrictions = [restrict_values[0]['minimum'],
                                        restrict_values[1]['maximum']]
                        restriction_type = 'range'
                    else:
                        restrictions = restrict_values
                        restriction_type = 'enum'
                description = prop.getDescription(width=100)
                presence = prop.getPresence()
                operations = prop.getOperations()
                default = prop.getElement().getDefault()
                mapped_default = self._type_genr._LangGenr.getMappedDefault(prop_type, default)
                prop_field_types.append("'%s': %s" %(name,
                                        {'is_complex': is_complex,
                                         'restrictions': restrictions,
                                         'restriction_type': restriction_type,
                                         'description': description,
                                         'required': presence,
                                         'operations': operations,
                                         'simple_type': simple_type,
                                         'xsd_type': xsd_type,
                                         'default' : eval(mapped_default)}))
            write(gen_file, '    prop_field_types = {\n        %s\n    }\n' %(
                  ',\n        '.join(prop_field_types)))
            write(gen_file, "")
            ref_field_type_vals = [('%s_refs' %(ident.getLinkTo(li).getName().replace('-', '_')),
                                    (ident.getLinkTo(li).getName(),
                                     ident.getLink(li).getXsdType(),
                                     ident.isLinkDerived(li),
                                     ident.getLink(li).getDescription(width=100)),
                                   ) for li in ident.getLinksInfo()
                                     if ident.isLinkRef(li)]
            write(gen_file, "    ref_field_types = {}")
            for ref_field, (ref_type, ref_link_type, is_weakref, ref_desc) in ref_field_type_vals:
                write(gen_file, "    ref_field_types['%s'] = ('%s', '%s', %s, %s)"
                      %(ref_field, ref_type, ref_link_type, is_weakref, ref_desc))
            write(gen_file, "")
            backref_field_type_vals = [('%s_back_refs' %(ident.getLinkTo(li).getName().replace('-', '_')),
                                    (ident.getBackLinkFrom(li).getName(),
                                     ident.getBackLink(li).getXsdType(),
                                     ident.isLinkDerived(li))
                                   ) for li in ident.getBackLinksInfo()
                                     if ident.isLinkRef(li)]
            write(gen_file, "    backref_field_types = {}")
            for backref_field, (backref_type, backref_link_type, is_weakref) in backref_field_type_vals:
                write(gen_file, "    backref_field_types['%s'] = ('%s', '%s', %s)"
                      %(backref_field, backref_type, backref_link_type, is_weakref))
            write(gen_file, "")
            children_field_type_vals = [('%ss' %(child_ident.getName().replace('-', '_')),
                                         (child_ident.getName(),
                                          child_ident.isDerived(ident)))
                                        for child_ident in ident.getChildren()]
            write(gen_file, "    children_field_types = {}")
            for child_field, (child_type, is_derived) in children_field_type_vals:
                write(gen_file, "    children_field_types['%s'] = ('%s', %s)"
                    %(child_field, child_type, is_derived))
            write(gen_file, "")
            if parents:
                p_class_names = [p_ident.getName() for p_ident, _, _ in parents]
                write(gen_file, "    parent_types = %s" %(p_class_names))
            else:
                write(gen_file, "    parent_types = ['config-root']")
            write(gen_file, "")
            prop_field_meta_vals = [('%s' %(prop.getName().replace('-', '_')),
                                     '%s' %(prop.getName())) for prop in ident.getProperties()]
            write(gen_file, "    prop_field_metas = {}")
            for k,v in prop_field_meta_vals:
                write(gen_file, "    prop_field_metas['%s'] = '%s'" %(k,v))
            write(gen_file, "")
            ref_field_meta_vals = [('%s_refs' %(ident.getLinkTo(li).getName().replace('-', '_')),
                                    '%s' %(ident.getLink(li).getName()))
                                   for li in ident.getLinksInfo()
                                   if ident.isLinkRef(li)]
            write(gen_file, "    ref_field_metas = {}")
            for ref_field, ref_meta in ref_field_meta_vals:
                write(gen_file, "    ref_field_metas['%s'] = '%s'"
                      %(ref_field, ref_meta))
            write(gen_file, "")
            children_field_meta_vals = [('%ss' %(ident.getLinkTo(li).getName().replace('-', '_')),
                                         '%s' %(ident.getLink(li).getName()))
                                        for li in ident.getLinksInfo()
                                        if ident.isLinkHas(li)]
            write(gen_file, "    children_field_metas = {}")
            for k,v in children_field_meta_vals:
                write(gen_file, "    children_field_metas['%s'] = '%s'" %(k,v))
            write(gen_file, "")
            prop_list_fields = [prop.getName().replace('-', '_')
                for prop in ident.getProperties() if prop.isList()]
            write(gen_file, "    prop_list_fields = set(%s)" %(prop_list_fields))
            write(gen_file, "")
            prop_list_field_has_wrapper_vals = [
                ('%s' %(prop.getName().replace('-', '_')),
                 prop.isListUsingWrapper()) for prop in ident.getProperties() if prop.isList()]
            write(gen_file, "    prop_list_field_has_wrappers = {}")
            for k,v in prop_list_field_has_wrapper_vals:
                write(gen_file, "    prop_list_field_has_wrappers['%s'] = %s" %(k,v))
            write(gen_file, "")

            prop_map_fields = [prop.getName().replace('-', '_')
                for prop in ident.getProperties() if prop.isMap()]
            write(gen_file, "    prop_map_fields = set(%s)" %(prop_map_fields))
            write(gen_file, "")
            prop_map_field_has_wrapper_vals = [
                ('%s' %(prop.getName().replace('-', '_')),
                 prop.isMapUsingWrapper()) for prop in ident.getProperties() if prop.isMap()]
            write(gen_file, "    prop_map_field_has_wrappers = {}")
            for k,v in prop_map_field_has_wrapper_vals:
                write(gen_file, "    prop_map_field_has_wrappers['%s'] = %s" %(k,v))
            write(gen_file, "")
            prop_map_field_key_name_vals = [
                ('%s' %(prop.getName().replace('-', '_')),
                 prop.getMapKeyName()) for prop in ident.getProperties() if prop.isMap()]
            write(gen_file, "    prop_map_field_key_names = {}")
            for k,v in prop_map_field_key_name_vals:
                write(gen_file, "    prop_map_field_key_names['%s'] = '%s'" %(k,v))
            write(gen_file, "")

            # init args are name, parent_obj(if there is one), props
            init_args = "self, name = None"
            if parents:
                init_args = init_args + ", parent_obj = None"
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                prop_type = prop.getElement().getType()
                default = prop.getElement().getDefault()
                mapped_default = self._type_genr._LangGenr.getMappedDefault(prop_type, default)
                init_args = init_args + ", %s=%s" %(prop_name, mapped_default)

            write(gen_file, "    def __init__(%s, *args, **kwargs):" %(init_args))
            write(gen_file, "        # type-independent fields")
            write(gen_file, "        self._type = '%s'" %(ident_name))
            write(gen_file, "        if not name:")
            write(gen_file, "            name = u'%s'" %(my_name_default))
            write(gen_file, "        self.name = name")
            write(gen_file, "        self._uuid = None")
            if parents:
                write(gen_file, "        # Determine parent type and fq_name")
                write(gen_file, "        kwargs_parent_type = kwargs.get('parent_type', None)")
                write(gen_file, "        kwargs_fq_name = kwargs.get('fq_name', None)")
                write(gen_file, "        if parent_obj:")
                write(gen_file, "            self.parent_type = parent_obj._type")
                write(gen_file, "            # copy parent's fq_name")
                write(gen_file, "            self.fq_name = list(parent_obj.fq_name)")
                write(gen_file, "            self.fq_name.append(name)")
                write(gen_file, "        elif kwargs_parent_type and kwargs_fq_name:")
                write(gen_file, "            self.parent_type = kwargs_parent_type")
                write(gen_file, "            self.fq_name = kwargs_fq_name")
                write(gen_file, "        else: # No parent obj specified")
                if len(parents) > 1:
                    # use config-root if it is one of the possible parents
                    if 'config-root' in [parent_ident.getName() for (parent_ident, meta, _) in parents]:
                        write(gen_file, "            self.fq_name = [name]")
                    else:
                        write(gen_file, "            # if obj constructed from within server, ignore if parent not specified")
                        write(gen_file, "            if not kwargs['parent_type']:")
                        parent_types = [parent_ident.getName() for parent_ident, _, _ in parents]
                        write(gen_file, "                raise AmbiguousParentError(\"%s\")" % parent_types)
                else: # only one possible parent
                    (parent_ident, meta, _) = parents[0]
                    if parent_ident.getName() == _BASE_PARENT:
                        write(gen_file, "            self.fq_name = [name]")
                    else: # parent is not config-root, but parent might have >1 parents
                        parent_name = parent_ident.getName()
                        try:
                            parent_default_fq_name = parent_ident.getDefaultFQName()
                            write(gen_file, "            self.parent_type = '%s'" %(parent_name))
                            write(gen_file, "            self.fq_name = %s" %(parent_default_fq_name))
                            write(gen_file, "            self.fq_name.append(name)")
                        except AmbiguousParentType as e:
                            write(gen_file, "            raise AmbiguousParentError(\"%s\")" %(e))
                        write(gen_file, "")
                    # end parent is config-root check
                # end num possible parents check
            else: # no parent in schema
                write(gen_file, "        self.fq_name = [name]")
            # end parents exist in schema check

            write(gen_file, "")

            write(gen_file, "        # property fields")
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                write(gen_file, "        if %s is not None:" %(prop_name))
                write(gen_file, "            self._%s = %s" %(prop_name, prop_name))

            write(gen_file, "    # end __init__")
            write(gen_file, "")

            # Getters for type independent fields
            write(gen_file, "    def get_type(self):")
            write(gen_file, '        """Return object type (%s)."""' %(ident_name))
            write(gen_file, "        return self._type")
            write(gen_file, "    # end get_type")
            write(gen_file, "")
            write(gen_file, "    def get_fq_name(self):")
            write(gen_file, '        """Return FQN of %s in list form."""' %(ident_name))
            write(gen_file, "        return self.fq_name")
            write(gen_file, "    # end get_fq_name")
            write(gen_file, "")
            write(gen_file, "    def get_fq_name_str(self):")
            write(gen_file, '        """Return FQN of %s as colon delimited string."""' %(ident_name))
            write(gen_file, "        return ':'.join(self.fq_name)")
            write(gen_file, "    # end get_fq_name_str")
            write(gen_file, "")
            if parents:
                write(gen_file, "    @property")
                write(gen_file, "    def parent_name(self):")
                write(gen_file, "        return self.fq_name[:-1][-1]")
                write(gen_file, "    # end parent_name")
                write(gen_file, "")
                write(gen_file, "    def get_parent_fq_name(self):")
                write(gen_file, '        """Return FQN of %s\'s parent in list form."""' %(ident_name))
                write(gen_file, "        if not hasattr(self, 'parent_type'):")
                write(gen_file, "            # child of config-root")
                write(gen_file, "            return None")
                write(gen_file, "")
                write(gen_file, "        return self.fq_name[:-1]")
                write(gen_file, "    # end get_parent_fq_name")
                write(gen_file, "")
                write(gen_file, "    def get_parent_fq_name_str(self):")
                write(gen_file, '        """Return FQN of %s\'s parent as colon delimted string."""' %(ident_name))
                write(gen_file, "        if not hasattr(self, 'parent_type'):")
                write(gen_file, "            # child of config-root")
                write(gen_file, "            return None")
                write(gen_file, "")
                write(gen_file, "        return ':'.join(self.fq_name[:-1])")
                write(gen_file, "    # end get_parent_fq_name_str")
                write(gen_file, "")

            # Getters and Setters for common fields
            write(gen_file, "    @property")
            write(gen_file, "    def uuid(self):")
            write(gen_file, "        return getattr(self, '_uuid', None)")
            write(gen_file, "    # end uuid")
            write(gen_file, "")
            write(gen_file, "    @uuid.setter")
            write(gen_file, "    def uuid(self, uuid_val):")
            write(gen_file, "        self._uuid = uuid_val")
            write(gen_file, "    # end uuid")
            write(gen_file, "")
            write(gen_file, "    def set_uuid(self, uuid_val):")
            write(gen_file, "        self.uuid = uuid_val")
            write(gen_file, "    # end set_uuid")
            write(gen_file, "")
            write(gen_file, "    def get_uuid(self):")
            write(gen_file, "        return self.uuid")
            write(gen_file, "    # end get_uuid")
            write(gen_file, "")

            # Getters and Setters for properties
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                prop_type = prop.getXsdType()
                write(gen_file, "    @property")
                write(gen_file, "    def %s(self):" %(prop_name))
                write(gen_file, '        """Get %s for %s.' %(prop.getName(), ident_name))
                write(gen_file, '        ')
                write(gen_file, '        :returns: %s object' % (prop_type))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        return getattr(self, '_%s', None)" %(prop_name))
                write(gen_file, "    # end %s" %(prop_name))
                write(gen_file, "")
                write(gen_file, "    @%s.setter" %(prop_name))
                write(gen_file, "    def %s(self, %s):" %(prop_name, prop_name))
                write(gen_file, '        """Set %s for %s.' %(prop.getName(), ident_name))
                write(gen_file, '        ')
                write(gen_file, '        :param %s: %s object' % (prop_name, prop_type))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        self._%s = %s" %(prop_name, prop_name))
                write(gen_file, "    # end %s" %(prop_name))
                write(gen_file, "")
                write(gen_file, "    def set_%s(self, value):" %(prop_name))
                write(gen_file, "        self.%s = value" %(prop_name))
                write(gen_file, "    # end set_%s" %(prop_name))
                write(gen_file, "")
                write(gen_file, "    def get_%s(self):" %(prop_name))
                write(gen_file, "        return self.%s" %(prop_name))
                write(gen_file, "    # end get_%s" %(prop_name))
                write(gen_file, "")

            write(gen_file, "    def _serialize_field_to_json(self, serialized, fields_to_serialize, field_name):")
            write(gen_file, "        if fields_to_serialize is None: # all fields are serialized")
            write(gen_file, "            serialized[field_name] = getattr(self, field_name)")
            write(gen_file, "        elif field_name in fields_to_serialize:")
            write(gen_file, "            serialized[field_name] = getattr(self, field_name)")
            write(gen_file, "    # end _serialize_field_to_json")
            write(gen_file, "")
            write(gen_file, "    def serialize_to_json(self, field_names = None):")
            write(gen_file, "        serialized = {}")
            write(gen_file, "")
            write(gen_file, "        # serialize common fields")
            write(gen_file, "        self._serialize_field_to_json(serialized, ['uuid'], 'uuid')")
            write(gen_file, "        self._serialize_field_to_json(serialized, field_names, 'fq_name')")
            write(gen_file, "        if hasattr(self, 'parent_type'):")
            write(gen_file, "            self._serialize_field_to_json(serialized, field_names, 'parent_type')")
            write(gen_file, "")

            write(gen_file, "        # serialize property fields")
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                write(gen_file, "        if hasattr(self, '_%s'):" %(prop_name))
                write(gen_file, "            self._serialize_field_to_json(serialized, field_names, '%s')" %(prop_name))
            write(gen_file, "")

            write(gen_file, "        # serialize reference fields")
            for link_info in ident.getLinksInfo():
                link = ident.getLink(link_info)
                to_ident = ident.getLinkTo(link_info)
                to_name = to_ident.getName().replace('-', '_')
                is_ref = ident.isLinkRef(link_info)
                if not is_ref:
                    continue
                write(gen_file, "        if hasattr(self, '%s_refs'):" %(to_name))
                write(gen_file, "            self._serialize_field_to_json(serialized, field_names, '%s_refs')" %(to_name))

            write(gen_file, "        return serialized")
            write(gen_file, "    # end serialize_to_json")

            write(gen_file, "")

            # Getters and Setters for all types of links
            # TODO use one loop of getLinksInfo for 'has', 'ref' and implicit backref
            for link_info in ident.getLinksInfo():
                link = ident.getLink(link_info)
                child_ident = ident.getLinkTo(link_info)
                child_name = child_ident.getName().replace('-', '_')
                is_has = ident.isLinkHas(link_info)
                if not is_has:
                    continue
                # only getter from parent to children
                write(gen_file, "    def get_%ss(self):" %(child_name))
                write(gen_file, "        return getattr(self, '%ss', None)" %(child_name))
                write(gen_file, "    # end get_%ss" %(child_name))
                write(gen_file, "")

            for link_info in ident.getLinksInfo():
                link = ident.getLink(link_info)
                to_ident = ident.getLinkTo(link_info)
                to_name = to_ident.getName().replace('-', '_')
                is_ref = ident.isLinkRef(link_info)
                if not is_ref:
                    continue
                set_one_args = "self, ref_obj"
                add_one_args = "self, ref_obj"
                del_one_args = "self, ref_obj"
                set_list_args = "self, ref_obj_list"
                if link.getXsdType(): # link with attr
                   set_one_args = set_one_args + ", ref_data=None"
                   add_one_args = set_one_args
                   set_list_args = set_list_args + ", ref_data_list"

                   set_one_val = "[{'to':ref_obj.get_fq_name(), 'attr':ref_data}]"
                   add_one_val = "{'to':ref_obj.get_fq_name(), 'attr':ref_data}"
                   set_list_val = "[{'to':ref_obj_list[i], 'attr':ref_data_list[i]} for i in range(len(ref_obj_list))]"
                else: # link with no attr
                   # TODO always put attr with None?
                   set_one_val = "[{'to':ref_obj.get_fq_name()}]"
                   add_one_val = "{'to':ref_obj.get_fq_name()}"
                   set_list_val = "ref_obj_list"
                write(gen_file, "    def set_%s(%s):" %(to_name, set_one_args))
                write(gen_file, '        """Set %s for %s.' %(to_ident.getName(), ident_name))
                write(gen_file, '        ')
                write(gen_file, '        :param ref_obj: %s object' %(CamelCase(to_ident.getName())))
                if link.getXsdType():
                    write(gen_file, '        :param ref_data: %s object' %(link.getXsdType()))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        self.%s_refs = %s" %(to_name, set_one_val))
                write(gen_file, "        if ref_obj.uuid:")
                write(gen_file, "            self.%s_refs[0]['uuid'] = ref_obj.uuid" %(to_name))
                write(gen_file, "")
                write(gen_file, "    # end set_%s" %(to_name))
                write(gen_file, "")
                write(gen_file, "    def add_%s(%s):" %(to_name, add_one_args))
                write(gen_file, '        """Add %s to %s.' %(to_ident.getName(), ident_name))
                write(gen_file, '        ')
                write(gen_file, '        :param ref_obj: %s object' %(CamelCase(to_ident.getName())))
                if link.getXsdType():
                    write(gen_file, '        :param ref_data: %s object' %(link.getXsdType()))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        refs = getattr(self, '%s_refs', [])" %(to_name))
                write(gen_file, "        if not refs:")
                write(gen_file, "            self.%s_refs = []" %(to_name))
                write(gen_file, "")
                write(gen_file, "        # check if ref already exists")
                if link.getXsdType(): # link with attr
                    write(gen_file, "        # update any attr with it")
                write(gen_file, "        for ref in refs:")
                write(gen_file, "            if ref['to'] == ref_obj.get_fq_name():")
                if link.getXsdType(): # link with attr
                    write(gen_file, "                if ref_data:")
                    write(gen_file, "                    ref['attr'] = ref_data")
                write(gen_file, "                return")
                write(gen_file, "")
                write(gen_file, "        # ref didn't exist before")
                write(gen_file, "        ref_info = %s" %(add_one_val))
                write(gen_file, "        if ref_obj.uuid:")
                write(gen_file, "            ref_info['uuid'] = ref_obj.uuid")
                write(gen_file, "")
                write(gen_file, "        self.%s_refs.append(ref_info)" %(to_name))
                write(gen_file, "    # end add_%s" %(to_name))
                write(gen_file, "")
                write(gen_file, "    def del_%s(%s):" %(to_name, del_one_args))
                write(gen_file, "        refs = self.get_%s_refs()" %(to_name))
                write(gen_file, "        if not refs:")
                write(gen_file, "            return")
                write(gen_file, "")
                write(gen_file, "        for ref in refs:")
                write(gen_file, "            if ref['to'] == ref_obj.get_fq_name():")
                write(gen_file, "                self.%s_refs.remove(ref)" %(to_name))
                write(gen_file, "                return")
                write(gen_file, "    # end del_%s" %(to_name))
                write(gen_file, "")
                write(gen_file, "    def set_%s_list(%s):" %(to_name, set_list_args))
                write(gen_file, '        """Set %s list for %s.' %(to_ident.getName(), ident_name))
                write(gen_file, '        ')
                write(gen_file, '        :param ref_obj_list: list of %s object' %(CamelCase(to_ident.getName())))
                if link.getXsdType():
                    write(gen_file, '        :param ref_data_list: list of %s object' %(link.getXsdType()))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        self.%s_refs = %s" %(to_name, set_list_val))
                write(gen_file, "    # end set_%s_list" %(to_name))
                write(gen_file, "")
                write(gen_file, "    def get_%s_refs(self):" %(to_name))
                write(gen_file, '        """Return %s list for %s.' %(to_ident.getName(), ident_name))
                write(gen_file, '        ')
                if link.getXsdType():
                    write(gen_file, '        :returns: list of tuple <%s, %s>' % (CamelCase(to_ident.getName()),
                                                link.getXsdType()))
                else:
                    write(gen_file, '        :returns: list of <%s>' % (CamelCase(to_ident.getName())))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        return getattr(self, '%s_refs', None)" %(to_name))
                write(gen_file, "    # end get_%s_refs" %(to_name))
                write(gen_file, "")

            # Getters for back reference links
            for back_link_info in ident.getBackLinksInfo():
                from_ident = ident.getBackLinkFrom(back_link_info)
                from_name = from_ident.getName().replace('-', '_')
                write(gen_file, "    def get_%s_back_refs(self):" %(from_name))
                write(gen_file, '        """Return list of all %ss using this %s"""' % (from_ident.getName(),ident_name))
                write(gen_file, "        return getattr(self, '%s_back_refs', None)" %(from_name))
                write(gen_file, "    # end get_%s_back_refs" %(from_name))
                write(gen_file, "")

            # dump method
            write(gen_file, "    def dump(self):")
            write(gen_file, '        """Display %s object in compact form."""' %(ident_name))
            write(gen_file, "        print '------------ %s ------------'" % (ident_name))
            write(gen_file, "        print 'Name = ', self.get_fq_name()")
            write(gen_file, "        print 'Uuid = ', self.uuid")
            if parents:
                write(gen_file, "        if hasattr(self, 'parent_type'): # non config-root children")
                write(gen_file, "            print 'Parent Type = ', self.parent_type")
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                write(gen_file, "        print 'P %s = ', self.get_%s()" %(prop_name, prop_name))
            for link_info in ident.getLinksInfo():
                to_ident = ident.getLinkTo(link_info)
                to_ident_name = to_ident.getName().replace('-', '_')
                is_ref = ident.isLinkRef(link_info)
                if is_ref:
                    write(gen_file, "        print 'REF %s = ', self.get_%s_refs()" %(to_ident_name, to_ident_name))
                else:
                    write(gen_file, "        print 'HAS %s = ', self.get_%ss()" %(to_ident_name, to_ident_name))
            for back_link_info in ident.getBackLinksInfo():
                if not ident.isLinkRef(back_link_info):
                    continue
                from_ident = ident.getBackLinkFrom(back_link_info)
                from_ident_name = from_ident.getName().replace('-', '_')
                write(gen_file, "        print 'BCK %s = ', self.get_%s_back_refs()" %(from_ident_name, from_ident_name))
            write(gen_file, "    # end dump")
            write(gen_file, "")

            write(gen_file, "# end class %s" %(class_name))
            write(gen_file, "")

    # end _generate_common_classes

    def _generate_client_classes(self, gen_filepath_pfx, gen_filename_pfx):
        gen_file = self._xsd_parser.makeFile(gen_filepath_pfx + "_client.py")
        write(gen_file, "")
        write(gen_file, "# AUTO-GENERATED file from %s. Do Not Edit!" \
              %(self.__class__.__name__))
        write(gen_file, "")
        write(gen_file, "import copy")
        write(gen_file, "import vnc_api.gen.%s_common" %(gen_filename_pfx))
        write(gen_file, "import vnc_api.gen.%s_xsd" %(gen_filename_pfx))
        write(gen_file, "try:")
        write(gen_file, "    from cfgm_common.exceptions import NoIdError")
        write(gen_file, "except ImportError:")
        write(gen_file, "    from vnc_api.exceptions import NoIdError")
        write(gen_file, "")

        write(gen_file, "")
        for ident in self._non_exclude_idents():
            parents = ident.getParents()
            class_name = CamelCase(ident.getName())
            method_name = ident.getName().replace('-', '_')
            write(gen_file, "class %s(vnc_api.gen.%s_common.%s):" \
                                   %(class_name, gen_filename_pfx, class_name))
            write(gen_file, "    create_uri = ''")
            write(gen_file, "    resource_uri_base = {}")

            # init args are name, parent_obj(if there is one), props
            init_args = "self, name=None"
            super_args = "name"
            if parents:
                init_args = init_args + ", parent_obj=None"
                super_args = super_args + ", parent_obj"

            write(gen_file, "    def __init__(%s, *args, **kwargs):" %(init_args))
            if parents:
                write(gen_file, "        pending_fields = ['fq_name', 'parent_type']")
            else:
                write(gen_file, "        pending_fields = ['fq_name']")
            write(gen_file, "")
            write(gen_file, "        self._server_conn = None")
            write(gen_file, "")
            for prop_index, prop in enumerate(ident.getProperties()):
                prop_name = prop.getName().replace('-', '_')
                prop_type = prop.getElement().getType()
                default = prop.getElement().getDefault()
                mapped_default = self._type_genr._LangGenr.getMappedDefault(prop_type, default)
                write(gen_file, "        if len(args) > %d or '%s' in kwargs:" % (prop_index, prop_name))
                write(gen_file, "            pending_fields.append('%s')" %(prop_name))

            write(gen_file, "")
            write(gen_file, "        self._pending_field_updates = set(pending_fields)")
            write(gen_file, "        # dict of prop-list-fields with list of opers")
            write(gen_file, "        self._pending_field_list_updates = {}")
            write(gen_file, "        # dict of prop-map-fields with list of opers")
            write(gen_file, "        self._pending_field_map_updates = {}")
            write(gen_file, "        self._pending_ref_updates = set([])")
            write(gen_file, "")
            write(gen_file, "        super(%s, self).__init__(%s, *args, **kwargs)" %(class_name, super_args))
            write(gen_file, "    # end __init__")
            write(gen_file, "")
            write(gen_file, "    def get_pending_updates(self):")
            write(gen_file, "        return self._pending_field_updates")
            write(gen_file, "    # end get_pending_updates")
            write(gen_file, "")
            write(gen_file, "    def get_ref_updates(self):")
            write(gen_file, "        return self._pending_ref_updates")
            write(gen_file, "    # end get_ref_updates")
            write(gen_file, "")
            write(gen_file, "    def clear_pending_updates(self):")
            write(gen_file, "        self._pending_field_updates = set([])")
            write(gen_file, "        self._pending_field_list_updates = {}")
            write(gen_file, "        self._pending_field_map_updates = {}")
            write(gen_file, "        self._pending_ref_updates = set([])")
            write(gen_file, "    # end clear_pending_updates")
            write(gen_file, "")
            write(gen_file, "    def set_server_conn(self, vnc_api_handle):")
            write(gen_file, "        self._server_conn = vnc_api_handle")
            write(gen_file, "    # end set_server_conn")
            write(gen_file, "")
            write(gen_file, "    @classmethod")
            write(gen_file, "    def from_dict(cls, **kwargs):")
            write(gen_file, "        props_dict = {}")
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                complex_type = prop.getCType()
                xsd_type = prop.getXsdType()
                write(gen_file, "        try:")
                if complex_type and xsd_type:
                    write(gen_file, "            if kwargs['%s'] is None:" % prop_name)
                    write(gen_file, "                props_dict['%s'] = None" % prop_name)
                    write(gen_file, "            else:")
                    if ((prop.isList() and not prop.isListUsingWrapper()) or
                        (prop.isMap() and not prop.isMapUsingWrapper())):
                        write(gen_file, "                props_dict['%s'] = []" %(prop_name))
                        write(gen_file, "                for elem in kwargs['%s']:" %(prop_name))
                        write(gen_file, "                    props_dict['%s'].append(" %(prop_name))
                        write(gen_file, "                        vnc_api.gen.%s_xsd.%s(**elem))" \
                                                                 %(gen_filename_pfx, xsd_type))
                    else:
                        write(gen_file, "                props_dict['%s'] = vnc_api.gen.%s_xsd.%s(params_dict=kwargs[u'%s'])" \
                                                                 %(prop_name, gen_filename_pfx, xsd_type, prop_name))
                else:
                    write(gen_file, "            props_dict['%s'] = kwargs[u'%s']" %(prop_name, prop_name))
                write(gen_file, "        except KeyError:")
                write(gen_file, "            pass")
                write(gen_file, "")

            write(gen_file, "")
            write(gen_file, "        # obj constructor takes only props")
            write(gen_file, "        parent_type = kwargs.get(u'parent_type', None)")
            write(gen_file, "        fq_name = kwargs[u'fq_name']")
            write(gen_file, "        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})")
            write(gen_file, "        obj = %s(fq_name[-1], **props_dict)" %(class_name))
            write(gen_file, "        obj.uuid = kwargs[u'uuid']")
            write(gen_file, "        try:")
            write(gen_file, "            obj.parent_uuid = kwargs[u'parent_uuid']")
            write(gen_file, "        except KeyError:")
            write(gen_file, "            pass")
            write(gen_file, "")
            write(gen_file, "        # add summary of any children...")
            children_idents = ident.getChildren()
            if children_idents:
                for child_ident in children_idents:
                    child_name = child_ident.getName()
                    child_method_name = child_name.replace('-', '_')
                    write(gen_file, "        try:")
                    write(gen_file, "            obj.%ss = kwargs[u'%ss']" %(child_method_name, child_method_name))
                    write(gen_file, "        except KeyError:")
                    write(gen_file, "            pass")
            write(gen_file, "")

            write(gen_file, "        # add any specified references...")
            for link_info in ident.getLinksInfo():
                if not ident.isLinkRef(link_info):
                    continue
                link = ident.getLink(link_info)
                link_name = link.getName()
                link_type = ident.getLink(link_info).getXsdType()
                to_ident = ident.getLinkTo(link_info)
                to_name = to_ident.getName().replace('-', '_')
                write(gen_file, "        try:")
                write(gen_file, "            obj.%s_refs = kwargs[u'%s_refs']" %(to_name, to_name))
                if link_type: # link with attributes
                    write(gen_file, "            for ref in obj.%s_refs:" %(to_name))
                    write(gen_file, "                ref['attr'] = vnc_api.gen.%s_xsd.%s(params_dict=ref[u'attr'])" %(gen_filename_pfx, link_type))
                write(gen_file, "        except KeyError:")
                write(gen_file, "            pass")

            write(gen_file, "")
            write(gen_file, "        # and back references but no obj api for it...")
            for back_link_info in ident.getBackLinksInfo():
                if not ident.isLinkRef(back_link_info):
                    continue
                back_link = ident.getLink(back_link_info)
                back_link_name = back_link.getName()
                back_link_type = ident.getLink(back_link_info).getXsdType()
                from_ident = ident.getBackLinkFrom(back_link_info)
                from_name = from_ident.getName().replace('-', '_')
                write(gen_file, "        try:")
                write(gen_file, "            obj.%s_back_refs = kwargs[u'%s_back_refs']" %(from_name, from_name))
                write(gen_file, "        except KeyError:")
                write(gen_file, "            pass")

            write(gen_file, "")
            write(gen_file, "        return obj")
            write(gen_file, "    # end from_dict")
            write(gen_file, "")

            # Setters for common fields
            write(gen_file, "    @vnc_api.gen.%s_common.%s.uuid.setter" %(gen_filename_pfx, class_name))
            write(gen_file, "    def uuid(self, uuid_val):")
            write(gen_file, "        self._uuid = uuid_val")
            write(gen_file, "        if 'uuid' not in self._pending_field_updates:")
            write(gen_file, "            self._pending_field_updates.add('uuid')")
            write(gen_file, "    # end uuid")
            write(gen_file, "")
            write(gen_file, "    def set_uuid(self, uuid_val):")
            write(gen_file, "        self.uuid = uuid_val")
            write(gen_file, "    # end set_uuid")
            write(gen_file, "")

            # Setters for properties
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                prop_type = prop.getXsdType()
                write(gen_file, "    @vnc_api.gen.%s_common.%s.%s.setter" %(gen_filename_pfx, class_name, prop_name))
                write(gen_file, "    def %s(self, %s):" %(prop_name, prop_name))
                write(gen_file, '        """Set %s for %s.' %(prop.getName(), ident.getName()))
                write(gen_file, '        ')
                write(gen_file, '        :param %s: %s object' % (prop_name, prop_type))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        if '%s' not in self._pending_field_updates:" %(prop_name))
                write(gen_file, "            self._pending_field_updates.add('%s')" %(prop_name))
                write(gen_file, "")
                if prop.isList():
                    write(gen_file, "        if '%s' in self._pending_field_list_updates:" %(prop_name))
                    write(gen_file, "            # set clobbers earlier add/del on prop list elements")
                    write(gen_file, "            del self._pending_field_list_updates['%s']" %(prop_name))
                    write(gen_file, "")
                if prop.isMap():
                    write(gen_file, "        if '%s' in self._pending_field_map_updates:" %(prop_name))
                    write(gen_file, "            # set clobbers earlier add/del on prop map elements")
                    write(gen_file, "            del self._pending_field_map_updates['%s']" %(prop_name))
                    write(gen_file, "")
                write(gen_file, "        self._%s = %s" %(prop_name, prop_name))
                write(gen_file, "    # end %s" %(prop_name))
                write(gen_file, "")
                write(gen_file, "    def set_%s(self, value):" %(prop_name))
                write(gen_file, "        self.%s = value" %(prop_name))
                write(gen_file, "    # end set_%s" %(prop_name))
                write(gen_file, "")

            # Atomic Setters for properties that are lists
            for prop in ident.getProperties():
                if not prop.isList():
                    continue
                prop_name = prop.getName().replace('-', '_')
                write(gen_file, "    def add_%s(self, elem_value, elem_position=None):" %(prop_name))
                write(gen_file, '        """Add element to %s for %s.' %(prop.getName(), ident.getName()))
                write(gen_file, '        ')
                write(gen_file, '        :param elem_value: %s object' % (prop_type))
                write(gen_file, '        :param elem_position: optional string order-key')
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        if '%s' not in self._pending_field_list_updates:" %(prop_name))
                write(gen_file, "            self._pending_field_list_updates['%s'] = [" %(prop_name))
                write(gen_file, "                ('add', elem_value, elem_position)]")
                write(gen_file, "        else:")
                write(gen_file, "            self._pending_field_list_updates['%s'].append(" %(prop_name))
                write(gen_file, "                ('add', elem_value, elem_position))")
                write(gen_file, "    # end add_%s" %(prop_name))
                write(gen_file, "")
                write(gen_file, "    def del_%s(self, elem_position):" %(prop_name))
                write(gen_file, '        """Delete element from %s for %s.' %(prop.getName(), ident.getName()))
                write(gen_file, '        ')
                write(gen_file, '        :param elem_position: string indicating order-key')
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        if '%s' not in self._pending_field_list_updates:" %(prop_name))
                write(gen_file, "            self._pending_field_list_updates['%s'] = [" %(prop_name))
                write(gen_file, "                ('delete', None, elem_position)]")
                write(gen_file, "        else:")
                write(gen_file, "            self._pending_field_list_updates['%s'].append(" %(prop_name))
                write(gen_file, "                ('delete', None, elem_position))")
                write(gen_file, "    # end del_%s" %(prop_name))

            # Atomic Setters for properties that are maps
            for prop in ident.getProperties():
                if not prop.isMap():
                    continue
                prop_name = prop.getName().replace('-', '_')
                write(gen_file, "    def add_%s(self, elem):" %(prop_name))
                write(gen_file, '        """Add element to %s for %s.' %(prop.getName(), ident.getName()))
                write(gen_file, '        ')
                write(gen_file, '        :param elem: %s object' % (prop_type))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        elem_position = getattr(elem, '%s')" %(prop.getMapKeyName()))
                write(gen_file, "        if '%s' not in self._pending_field_map_updates:" %(prop_name))
                write(gen_file, "            self._pending_field_map_updates['%s'] = [" %(prop_name))
                write(gen_file, "                ('set', elem, elem_position)]")
                write(gen_file, "        else:")
                write(gen_file, "            self._pending_field_map_updates['%s'].append(" %(prop_name))
                write(gen_file, "                ('set', elem, elem_position))")
                write(gen_file, "    # end set_%s" %(prop_name))
                write(gen_file, "")
                write(gen_file, "    def del_%s(self, elem_position):" %(prop_name))
                write(gen_file, '        """Delete element from %s for %s.' %(prop.getName(), ident.getName()))
                write(gen_file, '        ')
                write(gen_file, '        :param elem_position: string indicating map-key')
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        if '%s' not in self._pending_field_map_updates:" %(prop_name))
                write(gen_file, "            self._pending_field_map_updates['%s'] = [" %(prop_name))
                write(gen_file, "                ('delete', None, elem_position)]")
                write(gen_file, "        else:")
                write(gen_file, "            self._pending_field_map_updates['%s'].append(" %(prop_name))
                write(gen_file, "                ('delete', None, elem_position))")
                write(gen_file, "    # end del_%s" %(prop_name))

            # Setters for references
            for link_info in ident.getLinksInfo():
                link = ident.getLink(link_info)
                to_ident = ident.getLinkTo(link_info)
                to_name = to_ident.getName().replace('-', '_')
                is_ref = ident.isLinkRef(link_info)
                if not is_ref:
                    continue
                write(gen_file, "    def set_%s(self, *args, **kwargs):" %(to_name))
                write(gen_file, '        """Set %s for %s.' %(to_ident.getName(), ident.getName()))
                write(gen_file, '        ')
                write(gen_file, '        :param ref_obj: %s object' %(CamelCase(to_ident.getName())))
                if link.getXsdType():
                    write(gen_file, '        :param ref_data: %s object' %(link.getXsdType()))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        self._pending_field_updates.add('%s_refs')" %(to_name))
                write(gen_file, "        self._pending_ref_updates.discard('%s_refs')" %(to_name))
                write(gen_file, "        super(%s, self).set_%s(*args, **kwargs)" %(class_name, to_name))
                write(gen_file, "")
                write(gen_file, "    # end set_%s" %(to_name))
                write(gen_file, "")
                write(gen_file, "    def add_%s(self, *args, **kwargs):" %(to_name))
                write(gen_file, '        """Add %s to %s.' %(to_ident.getName(), ident.getName()))
                write(gen_file, '        ')
                write(gen_file, '        :param ref_obj: %s object' %(CamelCase(to_ident.getName())))
                if link.getXsdType():
                    write(gen_file, '        :param ref_data: %s object' %(link.getXsdType()))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        if '%s_refs' not in self._pending_ref_updates|self._pending_field_updates:" %(to_name))
                write(gen_file, "            self._pending_ref_updates.add('%s_refs')" %(to_name))
                write(gen_file, "            self._original_%s_refs = copy.deepcopy(self.get_%s_refs() or [])" %(to_name, to_name))
                write(gen_file, "        super(%s, self).add_%s(*args, **kwargs)" %(class_name, to_name))
                write(gen_file, "    # end add_%s" %(to_name))
                write(gen_file, "")
                write(gen_file, "    def del_%s(self, *args, **kwargs):" %(to_name))
                write(gen_file, "        if '%s_refs' not in self._pending_ref_updates:" %(to_name))
                write(gen_file, "            self._pending_ref_updates.add('%s_refs')" %(to_name))
                write(gen_file, "            self._original_%s_refs = copy.deepcopy(self.get_%s_refs() or [])" %(to_name, to_name))
                write(gen_file, "        super(%s, self).del_%s(*args, **kwargs)" %(class_name, to_name))
                write(gen_file, "    # end del_%s" %(to_name))
                write(gen_file, "")
                write(gen_file, "    def set_%s_list(self, *args, **kwargs):" %(to_name))
                write(gen_file, '        """Set %s list for %s.' %(to_ident.getName(), ident.getName()))
                write(gen_file, '        ')
                write(gen_file, '        :param ref_obj_list: list of %s object' %(CamelCase(to_ident.getName())))
                if link.getXsdType():
                    write(gen_file, '        :param ref_data_list: list of %s summary' %(link.getXsdType()))
                write(gen_file, '        ')
                write(gen_file, '        """')
                write(gen_file, "        self._pending_field_updates.add('%s_refs')" %(to_name))
                write(gen_file, "        self._pending_ref_updates.discard('%s_refs')" %(to_name))
                write(gen_file, "        super(%s, self).set_%s_list(*args, **kwargs)" %(class_name, to_name))
                write(gen_file, "    # end set_%s_list" %(to_name))
                write(gen_file, "")

            # Getters for children links
            for child_ident in ident.getChildren():
                child_name = child_ident.getName()
                child_method_name = child_name.replace('-', '_')
                write(gen_file, "    def get_%ss(self):" %(child_method_name))
                write(gen_file, "        children = super(%s, self).get_%ss()" %(class_name, child_method_name))
                write(gen_file, "        if not children: # read it for first time")
                write(gen_file, "            # if object not created/read from lib can't service")
                write(gen_file, "            svr_conn = self._server_conn")
                write(gen_file, "            if not svr_conn:")
                write(gen_file, "                return None")
                write(gen_file, "")
                write(gen_file, "            try:")
                write(gen_file, "                obj = svr_conn.%s_read(id = self.uuid, fields = ['%ss'])" %(method_name, child_method_name))
                write(gen_file, "            except NoIdError:")
                write(gen_file, "                return None")
                write(gen_file, "            children = getattr(obj, '%ss', None)" %(child_method_name))
                write(gen_file, "            self.%ss = children" %(child_method_name))
                write(gen_file, "")
                write(gen_file, "        return children")
                write(gen_file, "    # end get_%ss" %(child_method_name))
                write(gen_file, "")
            write(gen_file, "")

            # Getters for back reference links
            for back_link_info in ident.getBackLinksInfo():
                if not ident.isLinkRef(back_link_info):
                    continue
                from_ident = ident.getBackLinkFrom(back_link_info)
                from_name = from_ident.getName().replace('-', '_')
                write(gen_file, "    def get_%s_back_refs(self):" %(from_name))
                write(gen_file, '        """Return list of all %ss using this %s"""' % (from_ident.getName(), ident.getName()))
                write(gen_file, "        back_refs = super(%s, self).get_%s_back_refs()" %(class_name, from_name))
                write(gen_file, "        if back_refs:")
                write(gen_file, "            return back_refs")
                write(gen_file, "        # if object not created/read from lib can't service")
                write(gen_file, "        svr_conn = self._server_conn")
                write(gen_file, "        if not svr_conn:")
                write(gen_file, "            return None")
                write(gen_file, "")
                write(gen_file, "        try:")
                write(gen_file, "            obj = svr_conn.%s_read(id = self.uuid, fields = ['%s_back_refs'])" %(method_name, from_name))
                write(gen_file, "        except NoIdError:")
                write(gen_file, "            return None")
                write(gen_file, "        back_refs = getattr(obj, '%s_back_refs', None)" %(from_name))
                write(gen_file, "        self.%s_back_refs = back_refs" %(from_name))
                write(gen_file, "")
                write(gen_file, "        return back_refs")
                write(gen_file, "    # end get_%s_back_refs" %(from_name))
                write(gen_file, "")

            write(gen_file, "# end class %s" %(class_name))
            write(gen_file, "")
    # end _generate_client_classes

    def _create_heat_template_params(self, prop_list):
        # print parameters
        for key,val in enumerate(prop_list):
            if not val['prop_list']:
                if val.get('prop_reqd') == "system-only":
                    continue
                prop_long_name = self._get_prop_long_name(val)
                write(self.gen_file_templ, "  %s:" %(prop_long_name))
                prop_type = self._get_heat_prop_type(val['prop_type'],
                                                     val['prop_is_array'])
                prop_type = self._convert_heat_template_type(prop_type)
                write(self.gen_file_templ, "    type: %s" %(prop_type).lower())
                if val['prop_desc']:
                    write(self.gen_file_templ, "    description: %s"
                        %(val['prop_desc']))
                else:
                    write(self.gen_file_templ, "    description: %s for the %s"
                        %(val['prop_name'], self.resource_dict['class']))
                if val.get('prop_opers'):
                    write(self.gen_file_templ, "    # operations: %s"
                        %(val['prop_opers']))
                if val.get('prop_reqd'):
                    write(self.gen_file_templ, "    # required: %s"
                        %(val['prop_reqd']))
                else:
                    write(self.gen_file_templ, "    # required: optional")
                continue
            self._create_heat_template_params(val['prop_list'])
    # end _create_heat_template_params

    def _create_heat_template_resources(self, prop_list, tabs, comma):
        # print resources
        tcomma = comma
        for key,val in enumerate(prop_list):
            prop_type = self._get_heat_prop_type(val['prop_type'],
                                                 val['prop_is_array'])
            if val.get('prop_reqd') == "system-only":
                continue
            if not val['prop_list']:
                prop_long_name = self._get_prop_long_name(val)
                if prop_type.startswith('LIST'):
                    write(self.gen_file_templ, "%s%s: [{ get_param: %s }]%s"
                        %(" "*tabs, prop_long_name, prop_long_name, tcomma))
                else:
                    write(self.gen_file_templ, "%s%s: { get_param: %s }%s"
                        %(" "*tabs, prop_long_name, prop_long_name, tcomma))
                continue
            prop_long_name = self._get_prop_long_name(val)
            write(self.gen_file_templ, "%s%s:" %(" "*tabs, prop_long_name))
            if prop_type.startswith("LIST"):
                tabs = tabs+2
                write(self.gen_file_templ, "%s[{" %(" "*tabs))
                comma = ","
            if prop_type == "MAP":
                tabs = tabs+2
                write(self.gen_file_templ, "%s{" %(" "*tabs))
                comma = ","
            self._create_heat_template_resources(val['prop_list'], tabs+2, comma)
            if prop_type == "MAP":
                write(self.gen_file_templ, "%s}%s" %(" "*tabs, tcomma))
                tabs = tabs-2
            if prop_type.startswith("LIST"):
                write(self.gen_file_templ, "%s}]%s" %(" "*tabs, tcomma))
                tabs = tabs-2
                comma = ""
    # end _create_heat_template_resources

    def _create_heat_env_params(self, prop_list):
        # print env parameters
        for key,val in enumerate(prop_list):
            prop_type = self._get_heat_prop_type(val['prop_type'], 0)
            if not val['prop_list']:
                if not val['prop_restr']:
                    prop_long_name = self._get_prop_long_name(val)
                    if prop_type == 'INTEGER':
                        write(self.gen_file_env, "  %s: %s" %(prop_long_name, 1))
                    elif prop_type == 'BOOLEAN':
                        write(self.gen_file_env, "  %s: %s" %(prop_long_name, 'True'))
                    elif prop_type == 'STRING':
                        write(self.gen_file_env, "  %s: '%s'" %(prop_long_name, "Something"))
                    continue
                prop_long_name = self._get_prop_long_name(val)
                if prop_type == 'INTEGER' or prop_type == 'BOOLEAN':
                    write(self.gen_file_env, "  %s: %s" %(prop_long_name, val['prop_restr'][0]))
                elif prop_type == 'STRING':
                    write(self.gen_file_env, "  %s: '%s'" %(prop_long_name, val['prop_restr'][0]))
            self._create_heat_env_params(val['prop_list'])
    # end _create_heat_env_params

    def _get_heat_prop_type(self, typename, is_array):
        if typename.lower().endswith(
            "integer") or typename.lower().endswith("time"):
            type = "INTEGER"
        elif typename.lower().endswith("string"):
            type = "STRING"
        elif typename.lower().endswith("boolean"):
            type = "BOOLEAN"
        elif typename.lower().endswith("list<string>"):
            type = "LIST"
        else:
            type = "MAP"

        if is_array:
            type = "LIST:" + type

        return type
    # end _get_heat_prop_type

    def _convert_heat_template_type(self, prop_type):
        if prop_type == "INTEGER" or prop_type == "LIST:INTEGER":
            return "number"
        if prop_type == "STRING" or prop_type == "LIST:STRING":
            return "string"
        if prop_type == "BOOLEAN" or prop_type == "LIST:BOOLEAN":
            return "boolean"
        return prop_type

    def _make_heat_prop_list(self, prop_list, prop_name, prop_type,
                             restrictions, description, required, operations,
                             is_array, prop_get_list, skip):
        is_list = False
        if self._get_heat_prop_type(prop_type, is_array).startswith('LIST'):
            is_list = True
        new_list = []
        prop_list.append({
            'prop_name': prop_name,
            'prop_type': prop_type,
            'prop_restr': restrictions,
            'prop_desc': description,
            'prop_reqd': required,
            'prop_opers': operations,
            'prop_is_array': is_array,
            'prop_list' : new_list,
            'prop_get_list' : prop_get_list,
            'prop_skip': skip,
            'prop_is_list': is_list,
        })
        return prop_list[-1]
    # end _make_heat_prop_list

    def _process_heat_complex_property(self, cls, prop_list, prop_name,
                                       prop_type, is_simple, is_array,
                                       desc, reqd, opers, prop_get_list):
        prop = self._make_heat_prop_list(prop_list, prop_name, prop_type,
                                         None, desc, reqd, opers, is_array,
                                         prop_get_list, False)
        new_list = prop['prop_list']
        new_prop_get_list = list(prop_get_list)
        new_prop_get_list.append(prop)
        for attr_name in cls.attr_fields:
            attr_is_complex = cls.attr_field_type_vals[attr_name]['is_complex']
            attr_type = cls.attr_field_type_vals[attr_name]['attr_type']
            attr_is_array = cls.attr_field_type_vals[attr_name]['is_array']
            attr_restrictions = cls.attr_field_type_vals[
                attr_name]['restrictions']
            desc = cls.attr_field_type_vals[attr_name]['description']
            attr_description = desc[0] if desc else None
            attr_reqd = cls.attr_field_type_vals[attr_name]['required']

            if not attr_is_complex:
                self._make_heat_prop_list(new_list, attr_name,
                                          attr_type, attr_restrictions,
                                          attr_description, attr_reqd, opers,
                                          attr_is_array, new_prop_get_list,
                                          False)
                continue

            # property type is complex
            new_cls = getattr(self.res_xsd, attr_type)
            self._process_heat_complex_property(new_cls, new_list, attr_name,
                attr_type, (not attr_is_complex), attr_is_array,
                attr_description, attr_reqd, opers, new_prop_get_list)
    # end _process_heat_complex_property

    def _make_heat_property_schema(self, val, tabs):
        prop_long_name = self._get_prop_long_name(val)
        write(self.gen_file, "%s%s: properties.Schema(" %(tabs*" ",
            prop_long_name.upper()))
        tabs = tabs+4
        prop_type = self._get_heat_prop_type(val['prop_type'],
                                             val['prop_is_array'])
        if prop_type.startswith('LIST'):
            prop_type = "LIST"
        write(self.gen_file, "%sproperties.Schema.%s," %(tabs*" ", prop_type))
        write(self.gen_file, "%s_('%s.')," %(tabs*" ",
            prop_long_name.upper()))
        write(self.gen_file, "%supdate_allowed=True," %(tabs*" "))
        write(self.gen_file, "%srequired=False," %(tabs*" "))
        if val['prop_restr']:
            write(self.gen_file, "%sconstraints=[" %(tabs*" "))
            if prop_type == "INTEGER":
                write(self.gen_file, "%s    constraints.Range(%s, %s),"
                    %(tabs*" ", val['prop_restr'][0], val['prop_restr'][1]))
            else:
                write(self.gen_file, "%s    constraints.AllowedValues(%s),"
                    %(tabs*" ", val['prop_restr']))
            write(self.gen_file, "%s]," %(tabs*" "))
        if val['prop_list']:
            if prop_type == 'LIST':
                write(self.gen_file, "%sschema=properties.Schema(" %(tabs*" "))
                tabs=tabs+4
                write(self.gen_file, "%sproperties.Schema.MAP," %(tabs*" "))
            write(self.gen_file, "%sschema={" %(tabs*" "))
            for key,value in enumerate(val['prop_list']):
                self._make_heat_property_schema(value, tabs+4)
            write(self.gen_file, "%s}" %(tabs*" "))
            if prop_type == 'LIST':
                tabs=tabs-4
                write(self.gen_file, "%s)" %(tabs*" "))
        tabs = tabs-4
        write(self.gen_file, "%s)," %(tabs*" "))
    # end _make_heat_property_schema

    def _make_heat_properties(self, prop_list, prop_names_list,
                              prop_names_uc_list):
        for key,val in enumerate(prop_list):
            prop_long_name = self._get_prop_long_name(val)
            prop_names_list.append("'"+prop_long_name+"'")
            prop_names_uc_list.append(prop_long_name.upper())
            if val['prop_list']:
                self._make_heat_properties(val['prop_list'], prop_names_list,
                                           prop_names_uc_list)
    # end _make_heat_properties

    def _get_prop_hierarchy(self, prop, print_index):
        if self.heat_handling == 0:
            prop_get_str = "self.properties"
        else:
            prop_get_str = "prop_diff"
        for key,value in enumerate(prop['prop_get_list']):
            if value['prop_name'].lower().endswith("ref_data"):
                continue
            idx_str = ""
            if value['prop_is_list']:
                idx_str = "[index_%s]" %(len(value['prop_get_list']))
            prop_long_name = self._get_prop_long_name(value)
            prop_get_str += ".get(self.%s, {})%s" %(prop_long_name.upper(), idx_str)
        idx_str = ""
        if prop['prop_is_list'] and not prop['prop_list'] and print_index:
            idx_str = "[index_%s]" %(len(prop['prop_get_list']))
        prop_long_name = self._get_prop_long_name(prop)
        prop_get_str += ".get(self.%s)%s" %(prop_long_name.upper(), idx_str)
        return prop_get_str
    # end _get_prop_hierarchy

    def _get_prop_long_name(self, prop):
        prop_get_str = ""
        for key,value in enumerate(prop['prop_get_list']):
            if value['prop_name'].lower().endswith("ref_data"):
                continue
            prop_get_str += "%s_" %(value['prop_name'])
        prop_get_str += "%s" %(prop['prop_name'])
        return prop_get_str
    # end _get_prop_long_name

    def _set_heat_properties_value(self, prop, tabs, obj_index, skip, is_ref_update):
        if prop['prop_name'].endswith("_refs"):
            return
        write(self.gen_file, "%sif %s is not None:" %(tabs*" ",
            self._get_prop_hierarchy(prop, False)))
        tabs=tabs+4
        prop_type = self._get_heat_prop_type(prop['prop_type'],
                                             prop['prop_is_array'])
        if prop_type.startswith('LIST'):
            write(self.gen_file, "%sfor index_%s in range(len(%s)):" %(tabs*" ",
                len(prop['prop_get_list']), self._get_prop_hierarchy(prop, False)))
            tabs=tabs+4
        if not prop['prop_list']:
            oper_str = "add" if prop['prop_is_list'] else "set"
            write(self.gen_file, "%sobj_%s.%s_%s(%s)"
                %(" "*tabs, obj_index, oper_str, prop['prop_name'], self._get_prop_hierarchy(prop, True)))
            return

        prop_name = prop['prop_name']
        prop_type = prop['prop_type']
        write(self.gen_file, "%sobj_%s = vnc_api.%s()" %(tabs*" ", obj_index+1, prop_type))

        for key,val in enumerate(prop['prop_list']):
            self._set_heat_properties_value(val, tabs, obj_index+1, 0, 0)

        if not skip:
            oper_str = "add" if prop['prop_is_list'] else "set"
            write(self.gen_file, "%sobj_%s.%s_%s(obj_%s)" %(tabs*" ", obj_index, oper_str, prop['prop_name'], obj_index+1))

        if is_ref_update:
            write(self.gen_file, "%sref_data_list.append(obj_%s)" %(" "*tabs, obj_index+1))
    # end _set_heat_properties_value

    def _get_heat_properties_value(self, prop, p_prop_name):
        if not prop['prop_list']:
            write(self.gen_file, "            '%s': obj.%s,"
                %(prop['prop_name'], p_prop_name))
            return

        for key,val in enumerate(prop['prop_list']):
            self._get_heat_properties_value(
                val, p_prop_name+".get_"+val['prop_name']+"()")
    # end _get_heat_properties_value

    def _gen_heat_common_resource_hdr(self):
        write(self.gen_file, "")
        write(self.gen_file, "# AUTO-GENERATED file from %s. Do Not Edit!" \
              %(self.__class__.__name__))
        write(self.gen_file, "")
        write(self.gen_file, "from contrail_heat.resources import contrail")
        write(self.gen_file, "try:")
        write(self.gen_file, "    from heat.common.i18n import _")
        write(self.gen_file, "except ImportError:")
        write(self.gen_file, "    pass")
        write(self.gen_file, "from heat.engine import attributes")
        write(self.gen_file, "from heat.engine import constraints")
        write(self.gen_file, "from heat.engine import properties")
        write(self.gen_file, "try:")
        write(self.gen_file, "    from heat.openstack.common import log as logging")
        write(self.gen_file, "except ImportError:")
        write(self.gen_file, "    from oslo_log import log as logging")
        write(self.gen_file, "import uuid")
        write(self.gen_file, "")
        write(self.gen_file, "from vnc_api import vnc_api")
        write(self.gen_file, "")
        write(self.gen_file, "LOG = logging.getLogger(__name__)")
        write(self.gen_file, "")
        write(self.gen_file, "")
        write(self.gen_file, "class Contrail%s(contrail.ContrailResource):" \
              %(self.resource_dict['class']))
    # end _gen_heat_common_resource_hdr

    def _build_heat_properties(self):
        for prop_name in self.cls.prop_fields:
            if prop_name in self.skip_list:
                continue
            prop_is_simple = not self.cls.prop_field_types[prop_name]['is_complex']
            prop_type = self.cls.prop_field_types[prop_name]['xsd_type']
            desc = self.cls.prop_field_types[prop_name]['description']
            prop_desc = desc[0] if desc else None
            prop_reqd = self.cls.prop_field_types[prop_name]['required']
            prop_opers = self.cls.prop_field_types[prop_name]['operations']
            if prop_is_simple:
                self._make_heat_prop_list(self.prop_list, prop_name, prop_type,
                                          None, prop_desc, prop_reqd,
                                          prop_opers, False, [], False)
                continue

            # complex object
            try:
                cls = getattr(self.res_xsd, prop_type)
            except:
                continue
            self._process_heat_complex_property(cls, self.prop_list,
                prop_name, prop_type, prop_is_simple, False,
                prop_desc, prop_reqd, prop_opers, [])
     # end _build_heat_properties

    def _build_heat_refs(self):
        for ref_name in self.cls.ref_fields:

            ref_type = self.cls.ref_field_types[ref_name][1]
            skip = False if ref_type is 'None' else True
            desc = self.cls.ref_field_types[ref_name][3]
            ref_desc = desc[0] if desc else None
            self._make_heat_prop_list(self.ref_list, ref_name, 'string', None,
                                      ref_desc, None, None, True, [], skip)
            ref_name = self.cls.ref_field_types[ref_name][0].replace("-", "_")
            ref_name = ref_name + "_refs_data"
            try:
                cls = getattr(self.res_xsd, ref_type)
            except:
                continue

            self._process_heat_complex_property(cls, self.ref_list,
                ref_name, ref_type, False, True,
                ref_desc, None, None, [])
     # end _build_heat_refs

    def _build_heat_parents(self):
        for parent_name in self.cls.parent_types:
            pname = parent_name.replace('-', '_')
            self._make_heat_prop_list(self.parent_list, pname, 'string',
                None, None, None, None, False, [], False)
     # end _build_heat_parents

    def _gen_heat_properties(self, prop_names_list, prop_names_uc_list):
        write(self.gen_file, "    PROPERTIES = (")
        write(self.gen_file, "        %s" %(", ".join(prop_names_uc_list)))
        write(self.gen_file, "    ) = (")
        write(self.gen_file, "        %s" %(", ".join(prop_names_list)))
        write(self.gen_file, "    )")
        write(self.gen_file, "")
    # end _gen_heat_properties

    def _gen_heat_templ_params(self):
        write(self.gen_file_templ, "heat_template_version: 2015-04-30")
        write(self.gen_file_templ, "")
        write(self.gen_file_templ, "description: >")
        write(self.gen_file_templ, "  HOT template to create a %s:"
            %(self.resource_dict['class']))
        write(self.gen_file_templ, "")
        write(self.gen_file_templ, "parameters:")
        self._create_heat_template_params(self.prop_list)
        self._create_heat_template_params(self.ref_list)
        self._create_heat_template_params(self.parent_list)
        write(self.gen_file_templ, "")
    # end _gen_heat_templ_params

    def _gen_heat_env_params(self):
        write(self.gen_file_env, "parameters:")
        self._create_heat_env_params(self.prop_list)
        self._create_heat_env_params(self.ref_list)
        self._create_heat_env_params(self.parent_list)
        write(self.gen_file_env, "")
    # end _gen_heat_env_params

    def _gen_heat_properties_schema(self):
        tabs = 4
        write(self.gen_file, "    properties_schema = {")
        for key,val in enumerate(self.prop_list):
            self._make_heat_property_schema(val, tabs+4)
        for key,val in enumerate(self.ref_list):
            self._make_heat_property_schema(val, tabs+4)
        for key,val in enumerate(self.parent_list):
            self._make_heat_property_schema(val, tabs+4)
        write(self.gen_file, "    }")
        write(self.gen_file, "")

        tabs=4
        write(self.gen_file, "%sattributes_schema = {" %(" "*tabs))
        tabs=tabs+4
        for key,val in enumerate(self.prop_list):
            prop_long_name = self._get_prop_long_name(val)
            write(self.gen_file, "%s%s: attributes.Schema(" %(" "*tabs,
                prop_long_name.upper()))
            tabs=tabs+4
            write(self.gen_file, "%s_('%s.')," %(tabs*" ",
                prop_long_name.upper()))
            tabs=tabs-4
            write(self.gen_file, "%s)," %(tabs*" "))

        for key,val in enumerate(self.ref_list):
            prop_long_name = self._get_prop_long_name(val)
            write(self.gen_file, "%s%s: attributes.Schema(" %(" "*tabs,
                prop_long_name.upper()))
            tabs=tabs+4
            write(self.gen_file, "%s_('%s.')," %(tabs*" ",
                prop_long_name.upper()))
            tabs=tabs-4
            write(self.gen_file, "%s)," %(tabs*" "))
        for key,val in enumerate(self.parent_list):
            prop_long_name = self._get_prop_long_name(val)
            write(self.gen_file, "%s%s: attributes.Schema(" %(" "*tabs,
                prop_long_name.upper()))
            tabs=tabs+4
            write(self.gen_file, "%s_('%s.')," %(tabs*" ",
                prop_long_name.upper()))
            tabs=tabs-4
            write(self.gen_file, "%s)," %(tabs*" "))
        tabs=tabs-4
        write(self.gen_file, "%s}" %(" "*tabs))
        write(self.gen_file, "")
        write(self.gen_file, "%supdate_allowed_keys = ('Properties',)" %(" "*tabs))
        write(self.gen_file, "")

    # end _gen_heat_properties_schema

    def _ref_create_handling(self):
        tabs = 8
        write(self.gen_file, "")
        for key,val in enumerate(self.ref_list):
            if val['prop_skip']:
                continue
            attr_str = ""
            ref_name = val['prop_name']
            if '_refs_data' in ref_name:
                ref_name = val['prop_name'].replace("_refs_data","")
                attr_str = ', obj_1'
            if not ref_name.endswith('_refs'):
                ref_name = ref_name+"_refs"
            ref_name_type = ref_name.replace("_","-")
            ref_name_type = ref_name.replace("_","-").replace("-refs", "")

            write(self.gen_file, "%s# reference to %s" %(" "*tabs, ref_name))
            if attr_str:
                write(self.gen_file, "%sif len(self.properties.get(self.%s) or []) != len(self.properties.get(self.%s_DATA) or []):" %(" "*tabs,
                        ref_name.upper(), ref_name.upper()))
                tabs = tabs+4
                write(self.gen_file, "%sraise Exception(_('%s: specify %s for each %s_data.'))" %(" "*tabs,
                        self.resource_name, ref_name, ref_name))
                tabs = tabs-4
                write(self.gen_file, "%sobj_1 = None" %(" "*tabs))
                self._set_heat_properties_value(val, tabs, 0, 1, 0)
                write(self.gen_file, "")

            if attr_str:
                tabs = tabs+8
            write(self.gen_file, "%sif self.properties.get(self.%s):" %(" "*tabs, ref_name.upper()))
            tabs = tabs+4
            if not attr_str:
                write(self.gen_file, "%sfor index_%s in range(len(%s)):" %(tabs*" ",
                    len(val['prop_get_list']), self._get_prop_hierarchy(val, False)))
                tabs = tabs+4
            write(self.gen_file, "%stry:" %(" "*tabs))
            tabs = tabs+4
            write(self.gen_file, "%sref_obj = self.vnc_lib().%s_read(" %(" "*tabs, ref_name.replace("_refs", "")))
            tabs = tabs+4
            write(self.gen_file, "%sid=self.properties.get(self.%s)[index_0]" %(" "*tabs, ref_name.upper()))
            tabs = tabs-4
            write(self.gen_file, "%s)" %(" "*tabs))
            tabs = tabs-4
            write(self.gen_file, "%sexcept vnc_api.NoIdError:" %(" "*tabs))
            tabs = tabs+4
            write(self.gen_file, "%sref_obj = self.vnc_lib().%s_read(" %(" "*tabs, ref_name.replace("_refs", "")))
            tabs = tabs+4
            write(self.gen_file, "%sfq_name_str=self.properties.get(self.%s)[index_0]" %(" "*tabs, ref_name.upper()))
            tabs = tabs-4
            write(self.gen_file, "%s)" %(" "*tabs))
            tabs = tabs-4
            write(self.gen_file, "%sexcept Exception as e:" %(" "*tabs))
            tabs = tabs+4
            write(self.gen_file, "%sraise Exception(_('%%s') %% str(e))" %(" "*tabs))
            tabs = tabs-4
            write(self.gen_file, "%sobj_0.add_%s(ref_obj%s)" %(" "*tabs, ref_name.replace("_refs", ""), attr_str))
	    write(self.gen_file, "")
            tabs = tabs-4
            if not attr_str:
                tabs = tabs-4
            if attr_str:
                tabs = tabs-8
    # _ref_create_handling

    def _ref_modify_handling(self):
        for key,val in enumerate(self.ref_list):
            if val['prop_skip']:
                continue
            ref_name = val['prop_name'].replace("_refs_data","")
            ref_name_type = ref_name.replace("_","-")

            tabs = 8
            write(self.gen_file, "%s# reference to %s" %(" "*tabs, ref_name))
	    ref_attr_data = False
            if not ref_name.endswith('_refs'):
                ref_attr_data = True
                ref_name = ref_name+"_refs"
            if ref_attr_data:
                write(self.gen_file, "%supdate = 0" %(" "*tabs))
                write(self.gen_file, "%sif not self.%s in prop_diff:" %(" "*tabs, ref_name.upper()))
                tabs=tabs+4
                write(self.gen_file, "%sref_obj_list = [ref['to'] for ref in obj_0.get_%s() or []]" %(" "*tabs, ref_name))
                tabs=tabs-4
                write(self.gen_file, "%selse:" %(" "*tabs))
                tabs=tabs+4
                write(self.gen_file, "%sref_obj_list = []" %(" "*tabs))
                write(self.gen_file, "%supdate = 1" %(" "*tabs))
                tabs=tabs-4

                write(self.gen_file, "%sif not self.%s_DATA in prop_diff:" %(" "*tabs, ref_name.upper()))
                tabs=tabs+4
                write(self.gen_file, "%sref_data_list = [ref['attr'] for ref in obj_0.get_%s() or []]" %(" "*tabs, ref_name))
                tabs=tabs-4
                write(self.gen_file, "%selse:" %(" "*tabs))
                tabs=tabs+4
                write(self.gen_file, "%sref_data_list = []" %(" "*tabs))
                tabs=tabs-4
                write(self.gen_file, "")
            else:
                write(self.gen_file, "%sref_obj_list = []" %(" "*tabs))

            self._set_heat_properties_value(val, tabs, 0, 1, 1)

            tabs=8
            write(self.gen_file, "%sif self.%s in prop_diff:" %(" "*tabs, ref_name.upper()))
            tabs = tabs+4
            write(self.gen_file, "%sfor index_%s in range(len(prop_diff.get(self.%s) or [])):" %(tabs*" ",
                len(val['prop_get_list']), ref_name.upper()))
            tabs = tabs+4
            write(self.gen_file, "%stry:" %(" "*tabs))
            tabs = tabs+4
            write(self.gen_file, "%sref_obj = self.vnc_lib().%s_read(" %(" "*tabs, ref_name.replace("_refs", "")))
            tabs = tabs+4
            write(self.gen_file, "%sid=prop_diff.get(self.%s)[index_0]" %(" "*tabs, ref_name.upper()))
            tabs = tabs-4
            write(self.gen_file, "%s)" %(" "*tabs))
            tabs = tabs-4
            write(self.gen_file, "%sexcept vnc_api.NoIdError:" %(" "*tabs))
            tabs = tabs+4
            write(self.gen_file, "%sref_obj = self.vnc_lib().%s_read(" %(" "*tabs, ref_name.replace("_refs", "")))
            tabs = tabs+4
            write(self.gen_file, "%sfq_name_str=prop_diff.get(self.%s)[index_0]" %(" "*tabs, ref_name.upper()))
            tabs = tabs-4
            write(self.gen_file, "%s)" %(" "*tabs))
            tabs = tabs-4
            write(self.gen_file, "%sexcept Exception as e:" %(" "*tabs))
            tabs = tabs+4
            write(self.gen_file, "%sraise Exception(_('%%s') %% str(e))" %(" "*tabs))
            tabs = tabs-4
            if ref_attr_data:
                write(self.gen_file, "%sref_obj_list.append(ref_obj.fq_name)" %(" "*tabs))
            else:
                write(self.gen_file, "%sref_obj_list.append({'to':ref_obj.fq_name})" %(" "*tabs))
            write(self.gen_file, "")
            tabs = tabs-4

            if ref_attr_data:
                tabs = tabs-4
                write(self.gen_file, "%sif len(ref_obj_list) != len(ref_data_list):" %(" "*tabs))
                tabs = tabs+4
                write(self.gen_file, "%sraise Exception(_('%s: specify %s_data for each %s.'))" %(" "*tabs,
                        self.resource_name, ref_name, ref_name))
                tabs = tabs-4
                write(self.gen_file, "")
                write(self.gen_file, "%sif update or ref_obj_list or ref_data_list:" %(" "*tabs))
                tabs = tabs+4
                write(self.gen_file, "%sobj_0.set_%s_list(ref_obj_list, ref_data_list)" %(" "*tabs, ref_name.replace("_refs", "")))
                tabs = tabs-4
            else:
                write(self.gen_file, "%sobj_0.set_%s_list(ref_obj_list)" %(" "*tabs, ref_name.replace("_refs", "")))

            write(self.gen_file, "%s# End: reference to %s" %(" "*tabs, ref_name))
            write(self.gen_file, "")

    def _gen_heat_handle_create(self):
        write(self.gen_file, "    @contrail.set_auth_token")
        write(self.gen_file, "    def handle_create(self):")
        if self.parent_list:
            parent_is_project = False
            tabs = 8
            write(self.gen_file, "%sparent_obj = None" %(" "*tabs))
            for key,val in enumerate(self.parent_list):
                if val['prop_name'].upper() == "PROJECT":
                    parent_is_project = True
                write(self.gen_file, "%sif parent_obj is None and self.properties.get(self.%s) and self.properties.get(self.%s) != 'config-root':" %(" "*tabs, val['prop_name'].upper(), val['prop_name'].upper()))
                tabs = tabs+4
                write(self.gen_file, "%stry:" %(" "*tabs))
                tabs = tabs+4
                write(self.gen_file, "%sparent_obj = self.vnc_lib().%s_read(fq_name_str=self.properties.get(self.%s))"
                    %(" "*tabs, self._uncamelize(val['prop_name']), val['prop_name'].upper()))
                tabs = tabs-4
                write(self.gen_file, "%sexcept vnc_api.NoIdError:" %(" "*tabs))
                tabs = tabs+4
                write(self.gen_file, "%sparent_obj = self.vnc_lib().%s_read(id=str(uuid.UUID(self.properties.get(self.%s))))"
                    %(" "*tabs, self._uncamelize(val['prop_name']), val['prop_name'].upper()))
                tabs = tabs-4
                write(self.gen_file, "%sexcept:" %(" "*tabs))
                tabs = tabs+4
                write(self.gen_file, "%sparent_obj = None" %(" "*tabs))
                tabs = tabs-4
                tabs = tabs-4
            write(self.gen_file, "")
            tabs = 8
            if parent_is_project:
                write(self.gen_file, "%sif parent_obj is None and self.properties.get(self.%s) != 'config-root':" %(" "*tabs, val['prop_name'].upper()))
                tabs = tabs+4
                write(self.gen_file, "%stenant_id = self.stack.context.tenant_id" %(" "*tabs))
                write(self.gen_file, "%sparent_obj = self.vnc_lib().project_read(id=str(uuid.UUID(tenant_id)))" %(" "*tabs))
                tabs = tabs-4
                write(self.gen_file, "")
            write(self.gen_file, "%sif parent_obj is None and self.properties.get(self.%s) != 'config-root':" %(" "*tabs, val['prop_name'].upper()))
            write(self.gen_file, "%s    raise Exception('Error: parent is not specified in template!')" %(" "*tabs))
            write(self.gen_file, "")
            write(self.gen_file, "        obj_0 = vnc_api.%s(name=self.properties[self.NAME],"
                %(self.resource_dict['class']))
            write(self.gen_file, "            parent_obj=parent_obj)")
        else:
            write(self.gen_file, "        obj_0 = vnc_api.%s(name=self.properties[self.NAME])"
                %(self.resource_dict['class']))
        write(self.gen_file, "")

        for key,val in enumerate(self.prop_list):
            if val['prop_skip']:
                continue
            tabs = 8
            self._set_heat_properties_value(val, tabs, 0, 0, 0)

        # reference object handling
        self._ref_create_handling()

        tabs = 8
        write(self.gen_file, "%stry:" %(" "*tabs))
        tabs = tabs+4
        write(self.gen_file, "%sobj_uuid = super(Contrail%s, self).resource_create(obj_0)"
            %(" "*tabs, self.resource_dict['class']))
        tabs = tabs-4
        write(self.gen_file, "%sexcept Exception as e:" %(" "*tabs))
        tabs = tabs+4
        write(self.gen_file, "%sraise Exception(_('%%s') %% str(e))" %(" "*tabs))
        tabs = tabs-4
        write(self.gen_file, "")
        write(self.gen_file, "%sself.resource_id_set(obj_uuid)" %(" "*tabs))
        write(self.gen_file, "")
    # end _gen_heat_handle_create

    def _gen_heat_handle_update(self):
        tabs = 4
        write(self.gen_file, "%s@contrail.set_auth_token" %(" "*tabs))
        write(self.gen_file, "%sdef handle_update(self, json_snippet, tmpl_diff, prop_diff):" %(" "*tabs))
        tabs = tabs+4
        write(self.gen_file, "%stry:" %(" "*tabs))
        tabs = tabs+4
        write(self.gen_file, "%sobj_0 = self.vnc_lib().%s_read(" %(" "*tabs, self.resource_dict['method']))
        tabs = tabs+4
        write(self.gen_file, "%sid=self.resource_id" %(" "*tabs))
        tabs = tabs-4
        write(self.gen_file, "%s)" %(" "*tabs))
        tabs = tabs-4
        write(self.gen_file, "%sexcept Exception as e:" %(" "*tabs))
        tabs = tabs+4
        write(self.gen_file, "%sraise Exception(_('%%s') %% str(e))" %(" "*tabs))
        write(self.gen_file, "")

        for key,val in enumerate(self.prop_list):
            if val['prop_skip']:
                continue
            tabs = 8
            self._set_heat_properties_value(val, tabs, 0, 0, 0)

        write(self.gen_file, "")

        # reference object handling
        self._ref_modify_handling()

        tabs = 8
        write(self.gen_file, "%stry:" %(" "*tabs))
        tabs = tabs+4
        write(self.gen_file, "%sself.vnc_lib().%s_update(obj_0)"
            %(" "*tabs, self.resource_dict['method']))
        tabs = tabs-4
        write(self.gen_file, "%sexcept Exception as e:" %(" "*tabs))
        tabs = tabs+4
        write(self.gen_file, "%sraise Exception(_('%%s') %% str(e))" %(" "*tabs))
        write(self.gen_file, "")

    # end _gen_heat_handle_update

    def _gen_heat_handle_delete(self):
        write(self.gen_file, "    @contrail.set_auth_token")
        write(self.gen_file, "    def handle_delete(self):")
        write(self.gen_file, "        if self.resource_id is None:")
        write(self.gen_file, "            return")
        write(self.gen_file, "")
        write(self.gen_file, "        try:")
        write(self.gen_file, "            self.vnc_lib().%s_delete(id=self.resource_id)"
            %(self.resource_dict['method']))
        write(self.gen_file, "        except Exception as ex:")
        write(self.gen_file, "            self._ignore_not_found(ex)")
        write(self.gen_file, "            LOG.warn(_('%s %%s already deleted.') %% self.name)"
            %(self.resource_dict['method']))
        write(self.gen_file, "")
    # end _gen_heat_handle_delete

    def _gen_heat_show_resource(self):
        write(self.gen_file, "    @contrail.set_auth_token")
        write(self.gen_file, "    def _show_resource(self):")
        write(self.gen_file, "        obj = self.vnc_lib().%s_read(id=self.resource_id)"
            %(self.resource_dict['method']))
        write(self.gen_file, "        obj_dict = obj.serialize_to_json()")
        write(self.gen_file, "        return obj_dict")
        write(self.gen_file, "")
        write(self.gen_file, "")
    # end _gen_heat_show_resource

    def _gen_heat_resource_mapping(self):
        class_name = self.resource_dict['class']
        write(self.gen_file, "def resource_mapping():")
        write(self.gen_file, "    return {")
        write(self.gen_file, "        'OS::ContrailV2::%s': Contrail%s," %(class_name, class_name))
        write(self.gen_file, "    }")
    # end _gen_heat_resource_mapping

    def _gen_heat_templ_resource_section(self):
        # generate template resource section
        write(self.gen_file_templ, "resources:")
        write(self.gen_file_templ, "  template_%s:"
            %(self.resource_dict['class']))
        write(self.gen_file_templ, "    type: OS::ContrailV2::%s"
            %(self.resource_dict['class']))
        write(self.gen_file_templ, "    properties:")
        self._create_heat_template_resources(self.prop_list, 6, "")
        self._create_heat_template_resources(self.ref_list, 6, "")
        self._create_heat_template_resources(self.parent_list, 6, "")
        write(self.gen_file_templ, "")
    # end _gen_heat_templ_resource_section

    def _uncamelize(self, name):
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1)

    def _generate_heat_resources(self, gen_filepath_pfx, gen_filename_pfx):
        # heat uses the generated code to build its resources
        # set the build path correctly and import resources
        heat_path = os.environ.get('HEAT_BUILDTOP') + '/api-lib/vnc_api/gen'
        sys.path.append(heat_path)
        self.res_cmn = importlib.import_module('resource_common')
        self.res_xsd = importlib.import_module('resource_xsd')

        # list of attributes we can skip
        self.skip_list = ["id_perms", "perms2"]
        #self.ref_special_handling_list = {}
        #self.ref_special_handling_list['virtual-machine-interface'] = 'virtual_network_refs'
        #self.ref_special_handling_list['instance-ip'] = 'virtual_network_refs'

        for ident in self._non_exclude_idents():
            #if ident.getName() != "virtual-machine-interface":
            #if ident.getName() != "network-policy":
            #if ident.getName() != "service-template":
            #if ident.getName() != "virtual-network":
            #    continue

            self.resource_name = ident.getName()
            class_name = CamelCase(ident.getName())
            self.cls = getattr(self.res_cmn, class_name)
            method_name = ident.getName().replace('-', '_')
            file_prefix = ident.getName().replace('-', '_')

            # resource file descriptor
            heat_resource_dir = heat_path + "/heat/resources/"
            if not os.path.exists(heat_resource_dir):
                os.makedirs(heat_resource_dir)
            self._generate_package(heat_resource_dir)
            self.gen_file = self._xsd_parser.makeFile(
                heat_resource_dir + file_prefix + "_heat.py")
            # template file descriptor
            heat_template_dir = heat_path + "/heat/template/"
            if not os.path.exists(heat_template_dir):
                os.makedirs(heat_template_dir)
            self._generate_package(heat_template_dir)
            self.gen_file_templ = self._xsd_parser.makeFile(
                heat_template_dir + file_prefix + "_heat.yaml")
            # env file descriptor
            heat_env_dir = heat_path + "/heat/env/"
            if not os.path.exists(heat_env_dir):
                os.makedirs(heat_env_dir)
            self._generate_package(heat_env_dir)
            self.gen_file_env = self._xsd_parser.makeFile(
                heat_env_dir + file_prefix + "_heat.env")

            heat_dir = heat_path + "/heat/"
            self._generate_package(heat_dir)

            self.resource_dict = {}
            self.prop_list = []
            self.resource_dict['class'] = class_name
            self.resource_dict['method'] = method_name
            self.resource_dict['props'] = self.prop_list

            # generate resource common header section
            self._gen_heat_common_resource_hdr()

            # name is by default
            self.prop_list.append({
                'prop_name': 'name',
                'prop_type': 'STRING',
                'prop_restr': None,
                'prop_desc': 'name for the %s' %(class_name),
                'prop_is_array': False,
                'prop_list' : [],
                'prop_get_list' : [],
                'prop_skip': True
            })

            # fq_name is by default
            self.prop_list.append({
                'prop_name': 'fq_name',
                'prop_type': 'STRING',
                'prop_restr': None,
                'prop_desc': 'fq_name for the %s' %(class_name),
                'prop_is_array': False,
                'prop_list' : [],
                'prop_get_list' : [],
                'prop_skip': True
            })

            # build heat properties
            self._build_heat_properties()

            # build heat reference properties
            self.ref_list = []
            self._build_heat_refs()

            # build heat parents
            self.parent_list = []
            self._build_heat_parents()

            prop_names_list = []
            prop_names_uc_list = []
            self._make_heat_properties(self.prop_list, prop_names_list,
                                       prop_names_uc_list)
            self._make_heat_properties(self.ref_list, prop_names_list,
                                       prop_names_uc_list)
            self._make_heat_properties(self.parent_list, prop_names_list,
                                       prop_names_uc_list)

            # generate resource properties section
            self._gen_heat_properties(prop_names_list, prop_names_uc_list)

            # generate resource properties_schema section
            self._gen_heat_properties_schema()

            # generate resource handle_create method
            self.heat_handling = 0
            self._gen_heat_handle_create()

            # generate resource handle_update method
            self.heat_handling = 1
            self._gen_heat_handle_update()

            # generate resource handle_delete method
            self._gen_heat_handle_delete()

            # generate resource _show_resource method
            self._gen_heat_show_resource()

            # generate resource mapping
            self._gen_heat_resource_mapping()

            # generate template parameters section
            self._gen_heat_templ_params()

            # generate resource mapping
            self._gen_heat_templ_resource_section()

            # generate template parameters section
            self._gen_heat_env_params()
    # end _generate_heat_resources

    def _generate_test_classes(self, gen_filepath_pfx, gen_filename_pfx):
        gen_file = self._xsd_parser.makeFile(gen_filepath_pfx + "_test.py")
        write(gen_file, "'''")
        write(gen_file, "This module defines the fixture classes for all config elements")
        write(gen_file, "'''")
        write(gen_file, "")
        write(gen_file, "# AUTO-GENERATED file from %s. Do Not Edit!" \
              %(self.__class__.__name__))
        write(gen_file, "")
        write(gen_file, "import cfixture")
        write(gen_file, "from vnc_api import vnc_api")
        write(gen_file, "try:")
        write(gen_file, "    from cfgm_common.exceptions import *")
        write(gen_file, "except ImportError:")
        write(gen_file, "    from vnc_api.exceptions import *")
        write(gen_file, "")
        write(gen_file, "from generatedssuper import GeneratedsSuper")
        write(gen_file, "")

        for ident in self._non_exclude_idents():
            ident_name = ident.getName()
            if ident_name == _BASE_PARENT:
                continue

            method_name = ident_name.replace('-', '_')
            class_name = CamelCase(ident.getName())
            parents = ident.getParents()
            write(gen_file, "class %sTestFixtureGen(cfixture.ContrailFixture):" %(class_name))
            write(gen_file, '    """')
            write(gen_file, '    Fixture for :class:`.%s`' % class_name)
            write(gen_file, '    """')
            if parents:
                init_args = 'self, conn_drv, %s_name=None, parent_fixt=None, auto_prop_val=False' %(method_name)
                init_ds = '''
        constructor

        Args:
            conn_drv (:class:`ConnectionDriver`): connection driver (eg. :class:`vnc_api.vnc_api.VncApi`, :class:`novaclient.client.Client`, etc)

        Kwargs:
            %s_name (str): Name of %s
            parent_fixt (:class:`.%sTestFixtureGen`): Parent fixture
''' % (method_name, method_name, CamelCase(parents[0][0].getName())) # TODO fix this to handle multiple possible parents
            else:
                init_args = 'self, conn_drv, %s_name=None, auto_prop_val=False' %(method_name)
                init_ds = '''
        constructor

        Args:
            conn_drv (:class:`ConnectionDriver`): connection driver (eg. :class:`vnc_api.vnc_api.VncApi`, :class:`novaclient.client.Client`, etc)

        Kwargs:
            %s_name (str): Name of %s
'''
            for link_info in ident.getLinksInfo():
                if ident.isLinkRef(link_info):
                    l_name = ident.getLinkTo(link_info).getName().replace ('-', '_')
                    link = ident.getLink(link_info)
                    if link.getXsdType():
                        init_args += ', %s_ref_infos = None' % (l_name)
                        init_ds += '            %s (list): list of tuple (:class:`%s`, :class: `%s`) type\n' % (
                            l_name, CamelCase(l_name), link.getXsdType())
                    else:
                        init_args += ', %s_refs = None' % (l_name)
                        init_ds += '            %s (list): list of :class:`%s` type\n' % (
                            l_name, CamelCase(l_name))

            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                ctype = prop._xelement.type
                init_args += ', %s=None' % (prop_name)
                init_ds += '            %s (instance): instance of :class:`%s`\n' % (
                            prop_name, ctype)

            write(gen_file, "    def __init__(%s):" %(init_args))
            write(gen_file, "        '''")
            write(gen_file, "        Create %sTestFixtureGen object" % class_name)
            write(gen_file, "        %s\n        '''" % init_ds)
            write(gen_file, "        super(%sTestFixtureGen, self).__init__()" %(class_name))
            write(gen_file, "        self._conn_drv = conn_drv")
            write(gen_file, "        if not %s_name:" %(method_name))
            write(gen_file, "            self._name = 'default-%s'" %(ident_name))
            write(gen_file, "        else:")
            write(gen_file, "            self._name = %s_name" %(method_name))
            write(gen_file, "        self._obj = None")
            if parents:
                write(gen_file, "        self._parent_fixt = parent_fixt")
            write(gen_file, "        self._auto_prop_val = auto_prop_val")
            for link_info in ident.getLinksInfo():
                if ident.isLinkRef(link_info):
                    link = ident.getLink(link_info)
                    if link.getXsdType():
                        write(gen_file, "        if %s_ref_infos:" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                        write(gen_file, "            for ln, ref in %s_ref_infos:" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                        write(gen_file, "                self.add_%s (ln, ref)" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                    else:
                        write(gen_file, "        if %s_refs:" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                        write(gen_file, "            for ln in %s_refs:" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                        write(gen_file, "                self.add_%s (ln)" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))

            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                write(gen_file, "        self.%s = %s" % (prop_name, prop_name))

            write(gen_file, "    # end __init__")
            write(gen_file, "")
            write(gen_file, "    def _update_links (self, update_server):")
            for link_info in ident.getLinksInfo():
                if ident.isLinkRef(link_info):
                    write(gen_file, "        for ln in self.get_%ss ():" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                    link = ident.getLink(link_info)
                    if link.getXsdType():
                        write(gen_file, "            self.add_%s (*ln.fixture (), update_server = update_server, add_link = False)" \
                                                               % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                    else:
                        write(gen_file, "            self.add_%s (ln.fixture (), update_server = update_server, add_link = False)" \
                                                               % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
            write(gen_file, "        return None")
            write(gen_file, "    # end _update_links")
            write(gen_file, "")
            for link_info in ident.getLinksInfo():
                if ident.isLinkRef(link_info):
                    link = ident.getLink(link_info)
                    if link.getXsdType():
                        lnnm = ident.getLinkTo(link_info).getName().replace (
                                '-', '_')
                        write(gen_file, "    def add_%s (self, lo, ref, update_server = True, add_link = True):" % (
                                    lnnm))
                        write(gen_file, "        '''")
                        write(gen_file, "        add :class:`%s` link to :class:`%s`" % (CamelCase(lnnm), class_name))
                        write(gen_file, "        Args:")
                        write(gen_file, "            lo (:class:`%s`): obj to link" % (CamelCase(lnnm)))
                        write(gen_file, "            ref (:class:`%s`): property of the link object" % (link.getXsdType()))
                        write(gen_file, "        '''")
                        write(gen_file, "        if self._obj:")
                        write(gen_file, "            self._obj.add_%s (lo, ref)" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                        write(gen_file, "            if update_server:")
                        write(gen_file, "                self._conn_drv.%s_update (self._obj)" %(method_name))
                        write(gen_file, "")
                        write(gen_file, "        if add_link:")
                        write(gen_file, "            self.add_link('%s', cfixture.ConrtailLink('%s', '%s', '%s', %s, (lo, ref)))" % (
                                        ident.getLinkTo(link_info).getName().replace ('-', '_'),
                                        ident.getLinkTo(link_info).getName().replace ('-', '_'),
                                        ident.getName().replace ('-', '_'),
                                        ident.getLinkTo(link_info).getName().replace('-', '_'),
                                        str (link_info[2])))
                    else:
                        lnnm = ident.getLinkTo(link_info).getName().replace (
                                '-', '_')
                        write(gen_file, "    def add_%s (self, lo, update_server = True, add_link = True):" % (lnnm))
                        write(gen_file, "        '''")
                        write(gen_file, "        add :class:`%s` link to :class:`%s`" % (CamelCase(lnnm), class_name))
                        write(gen_file, "        Args:")
                        write(gen_file, "            lo (:class:`%s`): obj to link" % (CamelCase(lnnm)))
                        write(gen_file, "        '''")
                        write(gen_file, "        if self._obj:")
                        write(gen_file, "            self._obj.add_%s (lo)" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                        write(gen_file, "            if update_server:")
                        write(gen_file, "                self._conn_drv.%s_update (self._obj)" %(method_name))
                        write(gen_file, "")
                        write(gen_file, "        if add_link:")
                        write(gen_file, "            self.add_link('%s', cfixture.ConrtailLink('%s', '%s', '%s', %s, lo))" % (
                                        ident.getLinkTo(link_info).getName().replace ('-', '_'),
                                        ident.getLinkTo(link_info).getName().replace ('-', '_'),
                                        ident.getName().replace ('-', '_'),
                                        ident.getLinkTo(link_info).getName().replace('-', '_'),
                                        str (link_info[2])))
                    write(gen_file, "    # end add_%s_link" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                    write(gen_file, "")
                    write(gen_file, "    def get_%ss (self):" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
                    write(gen_file, "        return self.get_links ('%s')" % (
                                    ident.getLinkTo(link_info).getName().replace ('-', '_')))
                    write(gen_file, "    # end get_%ss" % (ident.getLinkTo(link_info).getName().replace ('-', '_')))
            write(gen_file, "")
            write(gen_file, "    def populate (self):")
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                ctype = prop._xelement.type
                if ctype.startswith ('xsd:'):
                    popstr = 'GeneratedsSuper.populate_%s("%s")' % (
                            ctype.replace ('xsd:', ''), prop_name)
                else:
                    if prop.getElement().getMaxOccurs() > 1:
                        popstr = '[vnc_api.gen.%s_xsd.%s.populate()]' % (gen_filename_pfx, ctype)
                    else:
                        popstr = 'vnc_api.gen.%s_xsd.%s.populate()' % (gen_filename_pfx, ctype)
                write(gen_file, "        self._obj.set_%s(self.%s or %s)" % (
                            prop_name, prop_name, popstr))
            write(gen_file, "    # end populate")
            write(gen_file, "")
            write(gen_file, "    def setUp(self):")
            write(gen_file, "        super(%sTestFixtureGen, self).setUp()" %(class_name))

            if parents:
                if parents[-1][0]._name == 'config-root':
                    write(gen_file, "        # child of config-root")
                    write(gen_file, "        self._obj = vnc_api.%s(self._name)" %(class_name))
                else:
                    if len(parents) > 1:
                        parent_types = [parent_ident.getName() for parent_ident, _, _ in parents]
                        write(gen_file, "        if not self._parent_fixt:")
                        write(gen_file, "            raise AmbiguousParentError(\"%s\")" % parent_types)
                    else: # single parent in schema
                        (parent_ident, meta, _) = parents[0]
                        parent_name = parent_ident.getName()
                        parent_class_name = CamelCase(parent_name)
                        write(gen_file, "        if not self._parent_fixt:")
                        write(gen_file, "            self._parent_fixt = self.useFixture(%sTestFixtureGen(self._conn_drv, 'default-%s'))" \
                                                                                         %(parent_class_name, parent_name))
                    write(gen_file, "")
                    write(gen_file, "        self._obj = vnc_api.%s(self._name, self._parent_fixt.getObj ())" %(class_name))
            else: # no parents
                write(gen_file, "        self._obj = vnc_api.%s(self._name)" %(class_name))

            write(gen_file, "        try:")
            write(gen_file, "            self._obj = self._conn_drv.%s_read (fq_name=self._obj.get_fq_name())" %(method_name))
            write(gen_file, "            self._update_links (update_server=True)")
            write(gen_file, "        except NoIdError:")
            write(gen_file, "            self._update_links (update_server=False)")
            write(gen_file, "            if self._auto_prop_val:")
            write(gen_file, "                self.populate ()")
            write(gen_file, "            else:")
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                write(gen_file, "                self._obj.%s = self.%s" % (prop_name, prop_name))

            write(gen_file, "            self._conn_drv.%s_create(self._obj)" %(method_name))
            write(gen_file, "            # read back for server allocated values")
            write(gen_file, "            self._obj = self._conn_drv.%s_read(id = self._obj.uuid)" %(method_name))
            write(gen_file, "    # end setUp")
            write(gen_file, "")
            write(gen_file, "    def cleanUp(self):")
            write(gen_file, "        try:")
            write(gen_file, "            self._conn_drv.%s_delete(id = self._obj.uuid)" %(method_name))
            write(gen_file, "        except RefsExistError:")
            write(gen_file, "            return")
            if parents:
                write(gen_file, "        parent_fixt = getattr(self, '_parent_fixt', None)")
                write(gen_file, "        if parent_fixt:")
                write(gen_file, "            # non config-root child")
                write(gen_file, "            parent_obj = self._parent_fixt.getObj()")
                write(gen_file, "            # remove child from parent obj")
                write(gen_file, "            for child_obj in parent_obj.get_%ss() or []:" %(method_name))
                write(gen_file, "                if type(child_obj) == dict:")
                write(gen_file, "                    child_uuid = child_obj['uuid']")
                write(gen_file, "                else:")
                write(gen_file, "                    child_uuid = child_obj.uuid")
                write(gen_file, "                if child_uuid == self._obj.uuid:")
                write(gen_file, "                    parent_obj.%ss.remove(child_obj)" %(method_name))
                write(gen_file, "                    break")
                write(gen_file, "")
            write(gen_file, "    # end cleanUp")
            write(gen_file, "")
            write(gen_file, "    def getObj(self):")
            write(gen_file, "        return self._obj")
            write(gen_file, "    # end getObj")
            write(gen_file, "")
            write(gen_file, "# end class %sTestFixtureGen" %(class_name))
            write(gen_file, "")
    # end _generate_test_classes

    def _generate_conn_drv_impl(self, gen_fname, gen_type_pfx):
        gen_file = self._xsd_parser.makeFile(gen_fname)
        write(gen_file, "")
        write(gen_file, "# AUTO-GENERATED file from %s. Do Not Edit!" \
              %(self.__class__.__name__))
        write(gen_file, "")
        write(gen_file, "import abc")
        write(gen_file, "")

        write(gen_file, "class ConnectionDriverBase(object):")
        write(gen_file, '    """')
        write(gen_file, "    This class provides type specific methods to create,")
        write(gen_file, "    read, update, delete and list objects from the server")
        write(gen_file, '    """')
        write(gen_file, "")
        write(gen_file, "    __metaclass__ = abc.ABCMeta")
        write(gen_file, "")
        write(gen_file, "    @abc.abstractmethod")
        write(gen_file, "    def __init__(self):")
        write(gen_file, "        pass")
        write(gen_file, "    # end __init__")

        for ident in self._non_exclude_idents():
            ident_name = ident.getName()
            method_name = ident_name.replace('-', '_')
            camel_name = CamelCase(ident_name)
            parents = ident.getParents()

            write(gen_file, "    def %s_create(self, obj):" %(method_name))
            write(gen_file, '        """Create new %s.' % (ident_name))
            write(gen_file, '        ')
            write(gen_file, '        :param obj: :class:`.%s` object' % (camel_name))
            write(gen_file, '        ')
            write(gen_file, '        """')
            write(gen_file, "        raise NotImplementedError, '%s_create is %%s\\'s responsibility' %% (str(type (self)))" % method_name)
            write(gen_file, "    # end %s_create" %(method_name))
            write(gen_file, "")

            write(gen_file, "    def %s_read(self, fq_name = None, fq_name_str = None, id = None, ifmap_id = None):" \
                                     %(method_name))
            write(gen_file, '        """Return %s information.' % (ident_name))
            write(gen_file, '        ')
            write(gen_file, '        :param fq_name: Fully qualified name of %s' % (ident_name))
            write(gen_file, '        :param fq_name_str: Fully qualified name string of %s' % (ident_name))
            write(gen_file, '        :param id: UUID of %s' % (ident_name))
            write(gen_file, '        :param ifmap_id: IFMAP id of %s' % (ident_name))
            write(gen_file, '        :returns: :class:`.%s` object' % (camel_name))
            write(gen_file, '        ')
            write(gen_file, '        """')
            write(gen_file, "        raise NotImplementedError, '%s_read is %%s\\'s responsibility' %% (str(type (self)))" % method_name)
            write(gen_file, "    # end %s_read" %(method_name))
            write(gen_file, "")

            write(gen_file, "    def %s_update(self, obj):" %(method_name))
            write(gen_file, '        """Update %s.' % (ident_name))
            write(gen_file, '        ')
            write(gen_file, '        :param obj: :class:`.%s` object' % (camel_name))
            write(gen_file, '        ')
            write(gen_file, '        """')
            write(gen_file, "        raise NotImplementedError, '%s_update is %%s\\'s responsibility' %% (str(type (self)))" % method_name)
            write(gen_file, "    # end %s_update" %(method_name))
            write(gen_file, "")

            list_args = "self"
            if parents:
                list_args = list_args + ", parent_id = None, parent_fq_name = None"
            if ident.getReferences():
                list_args = list_args + ", back_ref_id = None"
            list_args = list_args + ", obj_uuids = None, fields = None, detail = False, count = False"
            write(gen_file, "    def %ss_list(%s):" \
                                     %(method_name, list_args))
            if parents:
                write(gen_file, '        """List all %ss.' % (ident_name))
                write(gen_file, '        ')
                write(gen_file, '        :param parent_id: UUID of parent as optional search filter')
                write(gen_file, '        :param parent_fq_name: full qualified name of parent as optional search filter')
                write(gen_file, '        :returns: list of :class:`.%s` objects' %(camel_name))
                write(gen_file, '        ')
                write(gen_file, '        """')
            else:
                write(gen_file, '        """List all %ss."""' % (ident_name))
            write(gen_file, "        raise NotImplementedError, '%ss_list is %%s\\'s responsibility' %% (str(type (self)))" % method_name)

            write(gen_file, "    # end %ss_list" %(method_name))
            write(gen_file, "")
            write(gen_file, "    def %s_delete(self, fq_name = None, id = None, ifmap_id = None):" \
                                     %(method_name))
            write(gen_file, '        """Delete %s from the system.' % (ident_name))
            write(gen_file, '        ')
            write(gen_file, '        :param fq_name: Fully qualified name of %s' % (ident_name))
            write(gen_file, '        :param id: UUID of %s' % (ident_name))
            write(gen_file, '        :param ifmap_id: IFMAP id of %s' % (ident_name))
            write(gen_file, '        ')
            write(gen_file, '        """')
            write(gen_file, "        raise NotImplementedError, '%s_delete is %%s\\'s responsibility' %% (str(type (self)))" % method_name)
            write(gen_file, "    # end %s_delete" %(method_name))
            write(gen_file, "")
            write(gen_file, "    def get_default_%s_id(self):" %(method_name))
            write(gen_file, '        """Return UUID of default %s."""' %(ident_name))
            write(gen_file, "        raise NotImplementedError, 'get_default_%s_delete is %%s\\'s responsibility' %% (str(type (self)))" % method_name)
            write(gen_file, "    # end get_default_%s_delete" %(method_name))
            write(gen_file, "")

        write(gen_file, "# end class ConnectionDriverBase")
        write(gen_file, "")

    # end _generate_conn_drv_impl


    def _generate_client_impl(self, gen_fname, gen_type_pfx):
        gen_file = self._xsd_parser.makeFile(gen_fname)
        write(gen_file, "")
        write(gen_file, "# AUTO-GENERATED file from %s. Do Not Edit!" \
              %(self.__class__.__name__))
        write(gen_file, "")
        write(gen_file, "all_resource_types = set([")
        for ident in self._non_exclude_idents():
            ident_name = ident.getName()
            write(gen_file, "    '%s'," %(ident_name))
        write(gen_file, "])")
        write(gen_file, "")
        write(gen_file, "all_resource_type_tuples = set([")
        for ident in self._non_exclude_idents():
            ident_name = ident.getName()
            write(gen_file, "    ('%s', '%s')," %
                  (ident_name.replace('-', '_'), ident_name))
        write(gen_file, "])")
    # end _generate_client_impl

    def _generate_extension_impl(self, gen_fname, gen_type_pfx):
        gen_file = self._xsd_parser.makeFile(gen_fname)
        write(gen_file, "")
        write(gen_file, "# AUTO-GENERATED file from %s. Do Not Edit!" \
              %(self.__class__.__name__))
        write(gen_file, "")
        write(gen_file, "class ResourceApiGen(object):")
        for ident in self._non_exclude_idents():
            ident_name = ident.getName()
            method_name = ident_name.replace('-', '_')
            write(gen_file, "    def pre_%s_create(self, resource_dict, **kwargs):" %(method_name))
            write(gen_file, '        """')
            write(gen_file, "        Method called before %s is created" %(ident_name))
            write(gen_file, '        """')
            write(gen_file, "        pass")
            write(gen_file, "    # end pre_%s_create" %(method_name))
            write(gen_file, "")
            write(gen_file, "    def post_%s_create(self, resource_dict, **kwargs):" %(method_name))
            write(gen_file, '        """')
            write(gen_file, "        Method called after %s is created" %(ident_name))
            write(gen_file, '        """')
            write(gen_file, "        pass")
            write(gen_file, "    # end post_%s_create" %(method_name))
            write(gen_file, "")
            write(gen_file, "    def pre_%s_read(self, resource_id, **kwargs):" %(method_name))
            write(gen_file, '        """')
            write(gen_file, "        Method called before %s is read" %(ident_name))
            write(gen_file, '        """')
            write(gen_file, "        pass")
            write(gen_file, "    # end pre_%s_read" %(method_name))
            write(gen_file, "")
            write(gen_file, "    def post_%s_read(self, resource_id, resource_dict, **kwargs):" %(method_name))
            write(gen_file, '        """')
            write(gen_file, "        Method called after %s is read" %(ident_name))
            write(gen_file, '        """')
            write(gen_file, "        pass")
            write(gen_file, "    # end post_%s_read" %(method_name))
            write(gen_file, "")
            write(gen_file, "    def pre_%s_update(self, resource_id, resource_dict," %(method_name))
            write(gen_file, "            prop_collection_updates=None, ref_update=None, **kwargs):")
            write(gen_file, '        """')
            write(gen_file, "        Method called before %s is updated" %(ident_name))
            write(gen_file, '        """')
            write(gen_file, "        pass")
            write(gen_file, "    # end pre_%s_update" %(method_name))
            write(gen_file, "")
            write(gen_file, "    def post_%s_update(self, resource_id, resource_dict, old_dict," %(method_name))
            write(gen_file, "            prop_collection_updates=None, ref_update=None, **kwargs):")
            write(gen_file, '        """')
            write(gen_file, "        Method called after %s is updated" %(ident_name))
            write(gen_file, '        """')
            write(gen_file, "        pass")
            write(gen_file, "    # end post_%s_update" %(method_name))
            write(gen_file, "")
            write(gen_file, "    def pre_%s_delete(self, resource_id, **kwargs):" %(method_name))
            write(gen_file, '        """')
            write(gen_file, "        Method called before %s is deleted" %(ident_name))
            write(gen_file, '        """')
            write(gen_file, "        pass")
            write(gen_file, "    # end pre_%s_delete" %(method_name))
            write(gen_file, "")
            write(gen_file, "    def post_%s_delete(self, resource_id, resource_dict, **kwargs):" %(method_name))
            write(gen_file, '        """')
            write(gen_file, "        Method called after %s is deleted" %(ident_name))
            write(gen_file, '        """')
            write(gen_file, "        pass")
            write(gen_file, "    # end post_%s_delete" %(method_name))
            write(gen_file, "")
        write(gen_file, "# end class ResourceApiGen")
    # end _generate_extension_impl

    def _generate_test_impl(self, gen_fname, gen_type_pfx):
        gen_file = self._xsd_parser.makeFile(gen_fname)
        write(gen_file, "")
        write(gen_file, "# AUTO-GENERATED file from %s. Do Not Edit!" \
              %(self.__class__.__name__))
        write(gen_file, "")
        write(gen_file, "import fixtures")
        write(gen_file, "import testtools")
        write(gen_file, "")
        write(gen_file, "from %s_test import *" %(gen_type_pfx))
        write(gen_file, "")
        class_name = CamelCase(os.path.basename(gen_fname.split('.py')[0]))
        write(gen_file, "class %s(testtools.TestCase, fixtures.TestWithFixtures):" %(class_name))
        for ident in self._non_exclude_idents():
            ident_name = ident.getName()
            if ident_name == _BASE_PARENT:
                continue

            camel_name = CamelCase(ident_name)
            method_name = ident_name.replace('-', '_')
            write(gen_file, "    def test_%s_crud(self):" %(method_name))
            write(gen_file, "        self.useFixture(%sTestFixtureGen(self._vnc_lib))" %(camel_name))
            write(gen_file, "    # end test_%s_crud" %(method_name))
            write(gen_file, "")

        write(gen_file, "# end class %s" %(class_name))
    # end _generate_test_impl

    def _generate_docs_schema(self, gen_fname, gen_type_pfx):
        gen_file = self._xsd_parser.makeFile(gen_fname)
        write(gen_file, "")
        write(gen_file, "# AUTO-GENERATED file from %s. Do Not Edit!" \
              %(self.__class__.__name__))
        write(gen_file, "")
        write(gen_file, "import pydot")
        write(gen_file, "")
        write(gen_file, "def generate_schema_graph():")
        write(gen_file, "    graph = pydot.Dot(graph_type='digraph')")
        write(gen_file, "")
        write(gen_file, "    # Generate node definitions and add to graph")
        for ident in self._non_exclude_idents():
            ident_name = ident.getName()
            method_name = ident_name.replace('-', '_')
            write(gen_file, "    %s_node = pydot.Node('%s')" %(method_name, ident_name))
            write(gen_file, "    graph.add_node(%s_node)" %(method_name))

        write(gen_file, "")
        write(gen_file, "    # Generate edge definitions and add to graph")
        for ident in self._non_exclude_idents():
            ident_name = ident.getName()
            #if ident_name == _BASE_PARENT:
            #    continue

            method_name = ident_name.replace('-', '_')

            for link_info in ident.getLinksInfo():
                to_ident = ident.getLinkTo(link_info)
                to_method_name = to_ident.getName().replace('-', '_')
                is_ref = ident.isLinkRef(link_info)
                is_has = ident.isLinkHas(link_info)
                if is_has:
                    child_ident = to_ident
                    child_method_name = child_ident.getName().replace('-', '_')
                    write(gen_file, "    graph.add_edge(pydot.Edge(%s_node, %s_node, color = 'red'))" %(method_name, child_method_name))
                elif is_ref:
                    write(gen_file, "    graph.add_edge(pydot.Edge(%s_node, %s_node, color = 'blue', constraint = False))" \
                                                                   %(method_name, to_method_name))

        write(gen_file, "")
        write(gen_file, "    return graph")
        write(gen_file, "# end generate_schema_graph")
        write(gen_file, "")
        write(gen_file, "def write_schema_graph(graph, filename):")
        write(gen_file, "    graph.write_xdot(filename)")
        write(gen_file, "# end write_schema_graph")
        write(gen_file, "")
    # end _generate_docs_schema

    def _generate_docs_openapi(self, gen_fname, gen_type_pfx, xsd_openapi_dict):
        gen_file = self._xsd_parser.makeFile(gen_fname)
        write(gen_file, "")
        openapi_dict = OrderedDict([
            ('swagger', '2.0'),
            ('info', OrderedDict([
                ('title', 'Contrail Configuration API'),
                ('version', '1.0.0'),
            ])),
            ('host', 'localhost:8082'),
            ('basePath', '/'),
            ('schemes', ['http']),
            ('produces', ['application/json']),
            ('consumes', ['application/json']),
            ('definitions', OrderedDict([
                ('Error', OrderedDict([
                    ('properties', OrderedDict([
                        ('message', OrderedDict([
                            ('type', 'string'),
                        ])),
                    ])),
                    ('required', ['message']),
                ])),
                ('FQName', OrderedDict([
                    ('properties', OrderedDict([
                        ('fq_name', OrderedDict([
                            ('description', 'Fully Qualified Name of resource'),
                            ('type', 'array'),
                            ('items', OrderedDict([
                                ('type', 'string'),
                            ])),
                        ])),
                    ])),
                    ('required', ['fq_name']),
                ])),
                ('Uuid', OrderedDict([
                    ('properties', OrderedDict([
                        ('uuid', OrderedDict([
                            ('type', 'string'),
                            ('format', 'uuid'),
                        ])),
                    ])),
                    ('required', ['uuid']),
                ])),
                ('Type', OrderedDict([
                    ('properties', OrderedDict([
                        ('type', OrderedDict([
                            ('type', 'string'),
                        ])),
                    ])),
                    ('required', ['type']),
                ])),
                ('TypeFQName', OrderedDict([
                   ('allOf', [
                       {'$ref': '#/definitions/Type'},
                       {'$ref': '#/definitions/FQName'},
                   ]),
                ])),
                ('Href', OrderedDict([
                    ('properties', OrderedDict([
                        ('href', OrderedDict([
                            ('type', 'string'),
                            ('format', 'url'),
                        ])),
                    ])),
                    ('required', ['href']),
                ])),
                ('To', OrderedDict([
                    ('properties', OrderedDict([
                        ('to', OrderedDict([
                            ('description', 'Fully Qualified Name of resource'),
                            ('type', 'array'),
                            ('items', OrderedDict([
                                ('type', 'string'),
                            ])),
                        ])),
                    ])),
                ])),
                ('ResourceListSummary', OrderedDict([
                    ('allOf', [
                        {'$ref': '#/definitions/FQName'},
                        {'$ref': '#/definitions/Uuid'},
                        {'$ref': '#/definitions/Href'},
                    ]),
                ])),
                ('ResourceReference', OrderedDict([
                    ('allOf', [
                        {'$ref': '#/definitions/Href'},
                        {'$ref': '#/definitions/Uuid'},
                        {'$ref': '#/definitions/To'},
                    ]),
                    ('required', ['to']),
                ])),
                ('ResourceCommon', OrderedDict([
                    ('allOf', [
                        {'$ref': '#/definitions/FQName'},
                        {'$ref': '#/definitions/Uuid'},
                    ]),
                    ('required', ['fq_name', 'uuid']),
                ])),
                ('ResourceWithParent', OrderedDict([
                    ('allOf', [
                        {'$ref': '#/definitions/ResourceCommon'},
                        {'properties': OrderedDict([
                            ('parent_type', OrderedDict([
                                ('type', 'string'),
                            ])),
                            ('parent_uuid', OrderedDict([
                                ('type', 'string'),
                                ('format', 'uuid'),
                            ])),
                        ]),},
                    ]),
                ])),
            ])),
            ('tags', [
                OrderedDict([
                    ('name', 'actions'),
                    ('description', 'Actions common to all resources'),
                ]),
                OrderedDict([
                    ('name', 'user-created'),
                    ('description', 'User created resource'),
                ]),
                OrderedDict([
                    ('name', 'system-created'),
                    ('description', 'System created resource'),
                ]),
            ]),
            ('paths', OrderedDict([
                ('/id-to-fqname', OrderedDict([
                    ('post', OrderedDict([
                        ('tags', [ 'actions' ]),
                        ('summary', 'Find type and fqname given resource id'),
                        ('parameters', [
                            OrderedDict([
                                ('in', 'body'),
                                ('schema', {
                                    '$ref': '#/definitions/Uuid',
                                }),
                                ('required', True),
                            ]),
                        ]),
                        ('responses', OrderedDict([
                            ('200', OrderedDict([
                                ('description', 'Success'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/TypeFQName'),
                                ])),
                            ])),
                            ('404', OrderedDict([
                                ('description', 'Not Found'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/Error'),
                                ])),
                            ])),
                        ])),
                    ])),
                ])),
                ('/fqname-to-id', OrderedDict([
                    ('post', OrderedDict([
                        ('tags', [ 'actions' ]),
                        ('summary', 'Find resource id given its type and fqname'),
                        ('parameters', [
                            OrderedDict([
                                ('in', 'body'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/TypeFQName'),
                                ])),
                            ]),
                        ]),
                        ('responses', OrderedDict([
                            ('200', OrderedDict([
                                ('description', 'Success'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/Uuid'),
                                ])),
                            ])),
                            ('404', OrderedDict([
                                ('description', 'Not Found'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/Error'),
                                ])),
                            ])),
                        ])),
                    ])),
                ])),
            ])),
            ('x-datamodel', OrderedDict([
                ('objects', OrderedDict({})),
                ('common-properties', OrderedDict([
                    ('id-perms', OrderedDict([
                        ('description', ''),
                        ('operations', 'CR'),
                        ('created-by', 'User (optional)'),
                        ('$ref', '#/definitions/IdPermsType'),
                    ])),
                    ('perms2', OrderedDict([
                        ('description', ''),
                        ('operations', 'CRU'),
                        ('created-by', 'User (optional)'),
                        ('$ref', '#/definitions/PermType2'),
                    ])),
                    ('annotations', OrderedDict([
                        ('description', ''),
                        ('operations', 'CRU'),
                        ('created-by', 'User (optional)'),
                    ])),
                    ('display-name', OrderedDict([
                        ('description', 'Display name user configured string(name) that can be updated any time. Used as openstack name.'),
                        ('operations', 'CRU'),
                        ('created-by', 'User (optional)'),
                    ])),
                ])),
            ])),
        ])
        openapi_dict['definitions'].update(
            xsd_openapi_dict['definitions'])

        definitions = openapi_dict['definitions']
        paths = openapi_dict['paths']
        tags = openapi_dict['tags']
        datamodel_objects = openapi_dict['x-datamodel']['objects']
        for ident in sorted(self._non_exclude_idents(), key=lambda i: i.getName()):
            parents = ident.getParents()
            ident_name = ident.getName()
            camel_name = CamelCase(ident_name)
            method_name = ident_name.replace('-', '_')

            tags.append(OrderedDict([
                ('name', ident_name),
                ('description', 'Operations on %s' %(ident_name)),
            ]))
            # Definitions init for ident
            definitions.update(OrderedDict([
                (camel_name+'Create', OrderedDict([
                    ('allOf', [
                        {'$ref': '#/definitions/FQName'},
                        OrderedDict([
                            ('properties', OrderedDict()),
                            ('required', []),
                        ]),
                    ]),
                ])),
                (camel_name+'ReadDetail', OrderedDict([
                    ('allOf', [
                        {'$ref': '#/definitions/FQName'},
                        {'properties': OrderedDict()},
                    ]),
                ])),
                (camel_name+'ReadAll', OrderedDict([
                    ('allOf', [
                        {'$ref': '#/definitions/FQName'},
                        {'properties': OrderedDict()},
                    ]),
                ])),
                (camel_name+'Update', OrderedDict([
                    ('properties', OrderedDict()),
                ])),
            ]))
            create_props = definitions[camel_name+'Create']['allOf'][1]['properties']
            create_required = definitions[camel_name+'Create']['allOf'][1]['required']
            read_detail_props = definitions[camel_name+'ReadDetail']['allOf'][1]['properties']
            read_all_props = definitions[camel_name+'ReadAll']['allOf'][1]['properties']
            update_props = definitions[camel_name+'Update']['properties']

            if parents:
                # grab only non config-root parent types
                parent_types = [p[0].getName() for p in parents if p[0].getName() != _BASE_PARENT]
                if parent_types:
                    create_props['parent_type'] = OrderedDict([
                        ('type', 'string'),
                        ('enum', parent_types),
                        ('description', 'Parent resource type'),
                    ])
                    create_required.append('parent_type')

            # Datamodel init for ident
            datamodel_objects[ident_name] = OrderedDict([
                ('description', ''),
                ('parents', OrderedDict()),
                ('properties', OrderedDict()),
                ('references', OrderedDict()),
            ])
            datamodel_props = datamodel_objects[ident_name]['properties']
            datamodel_refs = datamodel_objects[ident_name]['references']
            # compute datamodel details for object
            description = ident.getElement().attrs.get('description')
            if not description:
                description = ''
                for parent_ident, parent_link, is_derived in ident.getParents() or []:
                    parent_name = parent_ident.getName()
                    if parent_name == _BASE_PARENT:
                        continue
                    if len(ident.getParents()) > 1:
                        indent = ' '*4
                        description += 'When parent is %s,\n%s' %(parent_ident.getName(), indent)
                        description += ' '.join(parent_link.getDescription(width=100))
                        description += '\n'
                    else:
                        description += ' '.join(parent_link.getDescription(width=100))

                    datamodel_objects[ident_name]['parents'][parent_name] = OrderedDict([
                        ('is_derived', is_derived)])

            datamodel_objects[ident_name]['description'] = description

            # Definitions + Datamodel init for props of ident
            for prop in ident.getProperties():
                prop_name = prop.getName().replace('-', '_')
                prop_xml_elem = prop.getElement()
                complex_type = prop.getCType()
                xsd_type = prop.getXsdType()
                if prop.getName() in openapi_dict['x-datamodel']['common-properties']:
                    is_common_prop = True
                else:
                    is_common_prop = False
                enum_values = None
                range_values = None
                if xsd_type.startswith('xsd:'):
                    type_name = xsd_type
                elif not complex_type: # simpletype [with restriction]
                    type_name = prop.getElement().getType()
                    r_base = self._xsd_parser.SimpleTypeDict[xsd_type]
                    if r_base.values and isinstance(r_base.values[0], dict):
                        range_values = OrderedDict([
                            ('minimum', r_base.values[0]['minimum']),
                            ('maximum', r_base.values[1]['maximum'])])
                    elif r_base.values:
                        enum_values = {'enum': r_base.values}
                else: # complex
                    type_name = xsd_type

                presence = prop.getPresence()
                operations = prop.getOperations()
                description_values = None
                description = prop.getDescription(width=100)
                if description:
                    if isinstance(description, list):
                        description_values = {'description': ' '.join(description)}
                    else:
                        description_values = {'description': description}

                if type_name.startswith('xsd:'):
                    type_key = 'type'
                    type_val = type_name.replace('xsd:','').replace(
                                              'integer', 'number')
                else:
                    type_key = '$ref'
                    type_val = '#/definitions/%s' %(type_name)

                if 'C' in operations:
                    create_props[prop_name] = OrderedDict([(type_key, type_val)])
                if 'R' in operations:
                    read_detail_props[prop_name] = OrderedDict([(type_key, type_val)])
                    read_all_props[prop_name] = OrderedDict([(type_key, type_val)])
                if 'U' in operations:
                    update_props[prop_name] = OrderedDict([(type_key, type_val)])

                if not is_common_prop:
                    datamodel_props[prop.getName()] = OrderedDict([
                        (type_key, type_val),
                        ('operations', operations),
                    ])

                if enum_values:
                    if 'C' in operations:
                        create_props[prop_name].update(enum_values)
                    if 'R' in operations:
                        read_detail_props[prop_name].update(enum_values)
                        read_all_props[prop_name].update(enum_values)
                    if 'U' in operations:
                        update_props[prop_name].update(enum_values)

                    if not is_common_prop:
                        datamodel_props[prop.getName()].update(enum_values)
                elif range_values:
                    if 'C' in operations:
                        create_props[prop_name].update(range_values)
                    if 'R' in operations:
                        read_detail_props[prop_name].update(range_values)
                        read_all_props[prop_name].update(range_values)
                    if 'U' in operations:
                        update_props[prop_name].update(range_values)

                    if not is_common_prop:
                        datamodel_props[prop.getName()].update(range_values)

                if description_values:
                    if 'C' in operations:
                        create_props[prop_name].update(description_values)
                    if 'R' in operations:
                        read_detail_props[prop_name].update(description_values)
                        read_all_props[prop_name].update(description_values)
                    if 'U' in operations:
                        update_props[prop_name].update(description_values)

                    if not is_common_prop:
                        datamodel_props[prop.getName()].update(description_values)

                if presence == 'required':
                    create_required.append(prop_name)

                if not is_common_prop:
                    if 'system-only' not in presence.lower():
                        datamodel_props[prop.getName()]['created-by'] = 'user'
                    else:
                        datamodel_props[prop.getName()]['created-by'] = 'system'

                    if 'required' in presence.lower():
                        datamodel_props[prop.getName()]['required'] = True
                    else:
                        datamodel_props[prop.getName()]['required'] = False
            # end for all ident properties

            if not create_required:
                del definitions[camel_name+'Create']['allOf'][1]['required']

            # Definitions + Datamodel init for props of ident
            for link_info in ident.getLinksInfo():
                link = ident.getLink(link_info)
                to_ident = ident.getLinkTo(link_info)
                to_method_name = to_ident.getName().replace('-', '_')
                to_class_name = CamelCase(to_ident.getName())
                is_ref = ident.isLinkRef(link_info)
                if not is_ref:
                    continue
                presence = link.getPresence()
                operations = link.getOperations()
                link_attr_type = link.getXsdType()
                if link_attr_type:
                    definitions.update(OrderedDict([
                        (camel_name+to_class_name+'Refs', OrderedDict([
                            ('allOf', [
                                {'$ref': '#/definitions/ResourceReference'},
                                {'properties': {
                                    'attr': {
                                        '$ref': '#/definitions/%s' %(link_attr_type),
                                    },
                                },},
                            ]),
                        ])),
                    ]))
                    if 'C' in operations:
                        create_props['%s_refs' %(to_method_name)] = OrderedDict([
                            ('type', 'array'),
                            ('items',  OrderedDict([
                                ('$ref', '#/definitions/%s%sRefs' %(camel_name, to_class_name)),
                            ])),
                            ('description', 'List of %s references' %(
                                to_ident.getName())),
                        ])
                    if 'R' in operations:
                        read_detail_props['%s_refs' %(to_method_name)] = OrderedDict([
                            ('type', 'array'),
                            ('items',  OrderedDict([
                                ('$ref', '#/definitions/%s%sRefs' %(camel_name, to_class_name)),
                            ])),
                            ('description', 'List of %s references' %(
                                to_ident.getName())),
                        ])
                        read_all_props['%s_refs' %(to_method_name)] = OrderedDict([
                            ('type', 'array'),
                            ('items',  OrderedDict([
                                ('$ref', '#/definitions/%s%sRefs' %(camel_name, to_class_name)),
                            ])),
                            ('description', 'List of %s references' %(
                                to_ident.getName())),
                        ])
                    if 'U' in operations:
                        update_props['%s_refs' %(to_method_name)] = OrderedDict([
                            ('type', 'array'),
                            ('items',  OrderedDict([
                                ('$ref', '#/definitions/%s%sRefs' %(camel_name, to_class_name)),
                            ])),
                            ('description', 'List of %s references' %(
                                to_ident.getName())),
                        ])
                else: # link without attr
                    if 'C' in operations:
                        create_props['%s_refs' %(to_method_name)] = OrderedDict([
                            ('type', 'array'),
                            ('items',  OrderedDict([
                                ('$ref', '#/definitions/ResourceReference'),
                            ])),
                            ('description', 'List of %s references' %(
                                to_ident.getName())),
                        ])
                    if 'R' in operations:
                        read_detail_props['%s_refs' %(to_method_name)] = OrderedDict([
                            ('type', 'array'),
                            ('items',  OrderedDict([
                                ('$ref', '#/definitions/ResourceReference'),
                            ])),
                            ('description', 'List of %s references' %(
                                to_ident.getName())),
                        ])
                        read_all_props['%s_refs' %(to_method_name)] = OrderedDict([
                            ('type', 'array'),
                            ('items',  OrderedDict([
                                ('$ref', '#/definitions/ResourceReference'),
                            ])),
                            ('description', 'List of %s references' %(
                                to_ident.getName())),
                        ])
                    if 'U' in operations:
                        update_props['%s_refs' %(to_method_name)] = OrderedDict([
                            ('type', 'array'),
                            ('items',  OrderedDict([
                                ('$ref', '#/definitions/ResourceReference'),
                            ])),
                            ('description', 'List of %s references' %(
                                to_ident.getName())),
                        ])

                if 'system-only' not in presence.lower():
                    created_by = 'user'
                else:
                    created_by = 'system'
                datamodel_refs[to_ident.getName()] = OrderedDict([
                    ('created-by', created_by),
                    ('required', 'required' in presence.lower()),
                    ('operations', operations),
                    ('description', '\n'.join(link.getDescription(width=100))),
                ])
                if link_attr_type:
                    datamodel_refs[to_ident.getName()]['attr'] = OrderedDict([
                        ('$ref', '#/definitions/%s' %(link_attr_type))
                    ])

                if presence == 'required':
                    create_required.append('%s_refs' %(to_method_name))
            # end for all refs

            for back_link_info in ident.getBackLinksInfo():
                back_link = ident.getLink(back_link_info)
                is_back_ref = ident.isLinkRef(back_link_info)
                if not is_back_ref:
                    continue
                from_ident = ident.getBackLinkFrom(back_link_info)
                from_method_name = from_ident.getName().replace('-', '_')
                from_class_name = CamelCase(from_ident.getName())
                link_attr_type = back_link.getXsdType()
                if link_attr_type:
                    read_all_props['%s_back_refs' %(from_method_name)] = OrderedDict([
                        ('type', 'array'),
                        ('items',  OrderedDict([
                            ('$ref', '#/definitions/%s%sRefs' %(from_class_name, camel_name)),
                        ])),
                        ('description', 'List of %s back references' %(
                            from_ident.getName())),
                    ])
                else: # link without attr
                    read_all_props['%s_back_refs' %(from_method_name)] = OrderedDict([
                        ('type', 'array'),
                        ('items',  OrderedDict([
                            ('$ref', '#/definitions/ResourceReference'),
                        ])),
                        ('description', 'List of %s references' %(
                            from_ident.getName())),
                    ])
            # end for all backrefs

            path_tags = [ident_name]
            is_derived_set = set([pl['is_derived'] for _, pl in datamodel_objects[ident_name]['parents'].items()])
            if True in is_derived_set:
                path_tags.append('system-created')
            if False in is_derived_set:
                path_tags.append('user-created')

            paths.update(OrderedDict([
                ('/%s/{id}' %(ident_name), OrderedDict([
                    ('get', OrderedDict([
                        ('tags', path_tags + ['read']),
                        ('summary', 'Fetch a specific %s' %(ident_name)),
                        ('parameters', [
                            OrderedDict([
                                ('name', 'id'),
                                ('description', 'The id of resource'),
                                ('in', 'path'),
                                ('required', True),
                                ('type', 'string')
                            ]),
                            OrderedDict([
                                ('name', 'fields'),
                                ('description', 'If specified, backref and children fields '
                                                'to be returned (properties and refs always returned)'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                                ('collectionFormat', 'csv')
                            ]),
                            OrderedDict([
                                ('name', 'exclude_back_refs'),
                                ('description', 'If specified, backref fields will not be returned'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                                ('allowEmptyValue', True),
                            ]),
                            OrderedDict([
                                ('name', 'exclude_children'),
                                ('description', 'If specified, children fields will not be returned'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                                ('allowEmptyValue', True),
                            ]),
                            OrderedDict([
                                ('name', 'exclude_hrefs'),
                                ('description', 'Omit reporting href field for children/refs/backrefs.'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                                ('allowEmptyValue', True),
                            ]),
                        ]),
                        ('responses', OrderedDict([
                            ('200', OrderedDict([
                                ('description', 'Success'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/%sReadAll' %(camel_name)),
                                ])),
                            ])),
                            ('404', OrderedDict([
                                ('description', 'Not Found'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/Error'),
                                ])),
                            ])),
                        ])),
                    ])),
                    ('put', OrderedDict([
                        ('tags', path_tags + ['update']),
                        ('summary', 'Update a specific %s' %(ident_name)),
                        ('parameters', [
                            OrderedDict([
                                ('description', 'The id of resource'),
                                ('in', 'path'),
                                ('name', 'id'),
                                ('required', True),
                                ('type', 'string'),
                            ]),
                            OrderedDict([
                                ('in', 'body'),
                                ('name', '%s' %(ident_name)),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/%sUpdate' %(camel_name)),
                                ])),
                            ]),
                        ]),
                        ('responses', OrderedDict([
                            ('200', OrderedDict([
                                ('description', 'Success'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/Uuid'),
                                ])),
                            ])),
                            ('404', OrderedDict([
                                ('description', 'Not Found'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/Error'),
                                ])),
                            ])),
                        ])),
                    ])),
                    ('delete', OrderedDict([
                        ('tags', path_tags + ['delete']),
                        ('summary', 'Delete a specific %s' %(ident_name)),
                        ('parameters', [
                            OrderedDict([
                                ('description', 'The id of resource'),
                                ('in', 'path'),
                                ('name', 'id'),
                                ('required', True),
                                ('type', 'string'),
                            ]),
                        ]),
                        ('responses', OrderedDict([
                            ('200', OrderedDict([
                                ('description', 'Success'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/Uuid'),
                                ])),
                            ])),
                            ('404', OrderedDict([
                                ('description', 'Not Found'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/Error'),
                                ])),
                            ])),
                            ('409', OrderedDict([
                                ('description', 'Conflict'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/Error'),
                                ])),
                            ])),
                        ])),
                    ])),
                ])),
                ('/%ss' %(ident_name), OrderedDict([
                    ('get', OrderedDict([
                        ('tags', path_tags + ['list']),
                        ('summary', 'List collection of %s' %(ident_name)),
                        ('parameters', [
                            OrderedDict([
                                ('name', 'detail'),
                                ('description', 'Report all :ref:`property and reference <%sReadDetail-label>`'
                                                ' fields of resource' %(camel_name)),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'boolean'),
                                ('default', False),
                            ]),
                            OrderedDict([
                                ('name', 'fields'),
                                ('description', 'CSV List of specific :ref:`fields <%sReadAll-label>`'
                                                ' to report' %(camel_name)),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                                ('collectionFormat', 'csv'),
                                ('default', 'fq_name, uuid, href'),
                            ]),
                            OrderedDict([
                                ('name', 'filters'),
                                ('description', 'CSV List of <property field>==<value> to match for reported collection.'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                                ('collectionFormat', 'csv')
                            ]),
                            OrderedDict([
                                ('name', 'count'),
                                ('description', 'Only report count of resource collection matching anchor criteria'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'boolean'),
                                ('default', False),
                            ]),
                            OrderedDict([
                                ('name', 'exclude_hrefs'),
                                ('description', 'Omit reporting href field in collection report'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                                ('allowEmptyValue', True),
                            ]),
                            OrderedDict([
                                ('name', 'shared'),
                                ('description', 'Include globally shared resources in collection report'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'boolean'),
                            ]),
                            OrderedDict([
                                ('name', 'parent_type'),
                                ('description', 'This along with parent_fq_name_str can be used as anchor'
                                                ' for collection report'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                            ]),
                            OrderedDict([
                                ('name', 'parent_fq_name_str'),
                                ('description', 'This along with parent_type can be used as anchor'
                                                ' for collection report'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                            ]),
                            OrderedDict([
                                ('name', 'parent_id'),
                                ('description', 'List of csv parent uuids that form anchor'
                                                ' for collection report'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                                ('collectionFormat', 'csv'),
                            ]),
                            OrderedDict([
                                ('name', 'back_ref_id'),
                                ('description', 'List of csv backref uuids that form anchor'
                                                ' for collection report'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                                ('collectionFormat', 'csv'),
                            ]),
                            OrderedDict([
                                ('name', 'obj_uuids'),
                                ('description', 'List of object uuids for collection report'),
                                ('in', 'query'),
                                ('required', False),
                                ('type', 'string'),
                                ('collectionFormat', 'csv'),
                            ]),
                        ]),
                        ('responses', OrderedDict([
                            ('200', OrderedDict([
                                ('description', 'Success'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/ResourceListSummary'),
                                ])),
                            ])),
                        ])),
                    ])),
                    ('post', OrderedDict([
                        ('tags', path_tags + ['create']),
                        ('summary', 'Create a new %s' %(ident_name)),
                        ('parameters', [
                            OrderedDict([
                                ('in', 'body'),
                                ('name', '%s' %(ident_name)),
                                ('schema', {
                                    '$ref': '#/definitions/%sCreate' %(camel_name),
                                }),
                                ('required', True),
                                ('description', 'Body of %s resource' %(ident_name)),
                            ]),
                        ]),
                        ('responses', OrderedDict([
                            ('200', OrderedDict([
                                ('description', 'Success'),
                                ('schema', OrderedDict([
                                    ('$ref', '#/definitions/Uuid'),
                                ])),
                            ])),
                        ])),
                    ])),
                ])),
            ]))
        # end for all idents

        #pprint.pprint(dict(openapi_dict))
        #json.encoder.c_make_encoder = None
        write(gen_file, json.dumps(openapi_dict, indent=4))

        return openapi_dict
    # end _generate_docs_openapi

    def _generate_docs_asciidoc(self, gen_fname, gen_type_pfx, openapi_dict):
        def get_schema_str(item_info):
            if not item_info:
                return ''
            elif '$ref' in item_info:
                schema_type = item_info['$ref'].split('/')[-1]
                return '<<_%s,%s>>' %(schema_type.lower(), schema_type)
            elif 'type' in item_info:
                if item_info['type'].lower() == 'array':
                    if '$ref' in item_info['items']:
                        item_type = item_info['items']['$ref'].split('/')[-1]
                        return '<<_%s,%s>> array' %(item_type.lower(), item_type)
                    elif 'type' in item_info['items']:
                        item_type = item_info['items']['type']
                        return '< %s > array' %(item_type)
                elif 'enum' in item_info:
                    return '< enum %s > %s' %(item_info['type'],
                                              item_info['enum'])
                else:
                    return item_info['type']
            elif 'allOf' in item_info:
                return '\n'.join([get_schema_str(i)
                                 for i in item_info['allOf']])
            else:
                return ''
        # end get_schema_str

        def get_props_and_allof(defn_info):
            ret_props = OrderedDict({})
            ret_required = []
            for allof_item in defn_info.get('allOf', []):
                for item_key, item_info in allof_item.items():
                    if item_key == 'properties':
                        ret_props.update(item_info)
                    elif item_key == '$ref':
                        defn_type = item_info.split('/')[-1]
                        recurse_props, recurse_required = get_props_and_allof(
                            openapi_dict['definitions'][defn_type])
                        ret_props.update(recurse_props)
                        ret_required.extend(recurse_required)
                    elif item_key == 'required':
                        ret_required.extend(item_info)
                # for all keys in allof item
            # end for allof
            ret_props.update(defn_info.get('properties', {}))
            ret_required.extend(defn_info.get('required', []))
            return ret_props, ret_required
        # end get_props_and_allof

        gen_file = self._xsd_parser.makeFile(gen_fname)
        write(gen_file, "")
        write(gen_file, "= Contrail Configuration API")
        write(gen_file, "")
        write(gen_file, "")
        write(gen_file, "[[_overview]]")
        write(gen_file, "== Overview")
        write(gen_file, "")
        write(gen_file, "=== Version information")
        write(gen_file, "[%hardbreaks]")
        write(gen_file, "_Version_ : %s" %(openapi_dict['info']['version']))
        write(gen_file, "")
        write(gen_file, "")
        write(gen_file, "=== URI scheme")
        write(gen_file, "[%hardbreaks]")
        write(gen_file, "_Host_ : %s" %(openapi_dict['host']))
        write(gen_file, "_BasePath_ : %s" %(openapi_dict['basePath']))
        write(gen_file, "_Schemes_ : %s" %(openapi_dict['schemes']))
        write(gen_file, "")
        write(gen_file, "")
        write(gen_file, "=== Tags")
        write(gen_file, "")
        for tag_info in openapi_dict['tags']:
            write(gen_file, "* %s: %s" %(tag_info['name'],
                                         tag_info['description']))
        write(gen_file, "")

        write(gen_file, "=== Consumes")
        write(gen_file, "")
        write(gen_file, "* `application/json`")
        write(gen_file, "")
        write(gen_file, "")
        write(gen_file, "=== Produces")
        write(gen_file, "")
        write(gen_file, "* `application/json`")
        write(gen_file, "")
        write(gen_file, "")
        write(gen_file, "")
        write(gen_file, "")
        write(gen_file, "[[_paths]]")
        write(gen_file, "== Paths")
        write(gen_file, "")
        for path_name, path_info in openapi_dict['paths'].items():
            for oper_name, oper_info in path_info.items():
                write(gen_file, "[[%s_%s]]" %(path_name[1:], oper_name))
                write(gen_file, "=== %s" %(oper_info['summary']))
                write(gen_file, "....")
                write(gen_file, "%s %s" %(oper_name.upper(), path_name))
                write(gen_file, "....")
                write(gen_file, "")
                write(gen_file, "")
                write(gen_file, "=== Parameters")
                write(gen_file, "")
                write(gen_file, '[options="header", cols=".^1,.^3,.^10,.^4,.^2"]')
                write(gen_file, "|===")
                write(gen_file, "|Type|Name|Description|Schema|Default")
                for param_info in oper_info['parameters']:
                    type_str = '*%s*' %(param_info['in'])
                    if param_info['in'].lower() == 'path':
                        presence_str = '_required_'
                    elif (param_info.get('required') and
                          param_info['required']):
                        presence_str = '_required_'
                    else:
                        presence_str = '_optional_'
                    if 'name' in param_info:
                        name_str = '*%s*' %(param_info['name'])
                        desc_str = param_info.get('description', '')
                        if param_info['in'].lower() == 'query':
                            schema_str = get_schema_str(param_info)
                            default_str = param_info.get('default', '')
                        else:
                            schema_str = get_schema_str(param_info.get('schema'))
                            default_str = ''
                        write(gen_file, "|%s|%s %s|%s|%s|%s" %(
                            type_str, name_str, presence_str,
                            desc_str, schema_str, default_str))
                    else: # anonymous parameter
                        schema_type = param_info['schema']['$ref'].split(
                                          '/')[-1]
                        oap_props, oap_required = get_props_and_allof(
                            openapi_dict['definitions'][schema_type])
                        for oap_name, oap_info in oap_props.items():
                            name_str = '*%s*' %(oap_name)
                            if oap_name in oap_required:
                                presence_str = '_required_'
                            else:
                                presence_str = '_optional_'
                            desc_str = '%s' %(oap_info.get('description', ''))
                            schema_str = get_schema_str(oap_info)
                            default_str = ''
                            write(gen_file, "|%s|%s %s|%s|%s|%s" %(
                                type_str, name_str, presence_str, desc_str,
                                schema_str, default_str))

                # end all params on oper
                write(gen_file, "|===")
                write(gen_file, "")
                write(gen_file, "")
                write(gen_file, "==== Responses")
                write(gen_file, "")
                write(gen_file, '[options="header", cols=".^1,.^15,.^4"]')
                write(gen_file, "|===")
                write(gen_file, "|HTTP Code|Description|Schema")
                for rsp_code, rsp_info in oper_info['responses'].items():
                    code_str = "*%s*" %(rsp_code)
                    desc_str = "%s" %(rsp_info.get('description', ''))
                    schema_str = get_schema_str(rsp_info.get('schema'))
                    write(gen_file, "|%s|%s|%s" %(
                        code_str, desc_str, schema_str))
                # end all responses on oper
                write(gen_file, "|===")
                write(gen_file, "")
                write(gen_file, "")
                write(gen_file, "==== Tags")
                write(gen_file, "")
                for tag in oper_info.get('tags', []):
                    write(gen_file, "* %s" %(tag))
                write(gen_file, "")
            # end for all oper on path
            write(gen_file, "")
        # end for all paths

        write(gen_file, "")
        write(gen_file, "[[_definitions]]")
        write(gen_file, "== Definitions")
        write(gen_file, "")
        for defn_name, defn_info in openapi_dict['definitions'].items():
            write(gen_file, "[[_%s]]" %(defn_name.lower()))
            write(gen_file, "=== %s" %(defn_name))
            if 'allOf' in defn_info:
                write(gen_file, "[%hardbreaks]")
                write(gen_file, "_Polymorphism_ : Composition")

            write(gen_file, '[options="header", cols=".^3,.^11,.^4"]')
            write(gen_file, "|===")
            write(gen_file, "|Name|Description|Schema")
            oap_props, oap_required = get_props_and_allof(defn_info)
            for oap_name, oap_info in oap_props.items():
                name_str = '*%s*' %(oap_name)
                if oap_name in oap_required:
                    presence_str = '_required_'
                else:
                    presence_str = '_optional_'
                desc_str = '%s' %(oap_info.get('description', ''))
                schema_str = get_schema_str(oap_info)
                write(gen_file, "|%s %s|%s|%s" %(
                    name_str, presence_str, desc_str, schema_str))
            write(gen_file, "|===")
            write(gen_file, "")
        # end for all definitions
        write(gen_file, "")
    # end _generate_docs_asciidoc

    def _generate_docs_sphinx(self, gen_fname, gen_type_pfx, openapi_dict):
        def csv_scrub(col_str):
            return '"%s"' %(col_str.replace('\n', ' ').replace('"', "'"))

        def get_schema_str(item_info):
            if not item_info:
                return ''
            elif '$ref' in item_info:
                schema_type = item_info['$ref'].split('/')[-1]
                return '`%s`_' %(schema_type)
            elif 'type' in item_info:
                if item_info['type'].lower() == 'array':
                    if '$ref' in item_info['items']:
                        item_type = item_info['items']['$ref'].split('/')[-1]
                        return '`%s`_ array' %(item_type)
                    elif 'type' in item_info['items']:
                        item_type = item_info['items']['type']
                        return csv_scrub('< %s > array' %(item_type))
                elif 'enum' in item_info:
                    return csv_scrub('Any of %s' %([str(x) for x in item_info['enum']]))
                else:
                    return item_info['type']
            elif 'allOf' in item_info:
                return ' '.join([get_schema_str(i)
                                  for i in item_info['allOf']])
            else:
                return ''
        # end get_schema_str

        def get_schema_name(item_info):
            if not item_info:
                return []
            if '$ref' in item_info:
                schema_type = item_info['$ref'].split('/')[-1]
                return [schema_type]
            if 'type' in item_info:
                if item_info['type'].lower() == 'array':
                    if '$ref' in item_info['items']:
                        item_type = item_info['items']['$ref'].split('/')[-1]
                        return [item_type]
            elif 'allOf' in item_info:
                return [get_schema_name(i) for i in item_info['allOf']]
            return []
        # end get_schema_name

        def get_props_and_allof(defn_info):
            ret_props = OrderedDict()
            ret_required = []
            for allof_item in defn_info.get('allOf', []):
                for item_key, item_info in allof_item.items():
                    if item_key == 'properties':
                        ret_props.update(item_info)
                    elif item_key == '$ref':
                        defn_type = item_info.split('/')[-1]
                        recurse_props, recurse_required = get_props_and_allof(
                            openapi_dict['definitions'][defn_type])
                        ret_props.update(recurse_props)
                        ret_required.extend(recurse_required)
                    elif item_key == 'required':
                        ret_required.extend(item_info)
                # for all keys in allof item
            # end for allof
            ret_props.update(defn_info.get('properties', OrderedDict()))
            ret_required.extend(defn_info.get('required', []))
            return ret_props, ret_required
        # end get_props_and_allof

        gen_file = self._xsd_parser.makeFile(gen_fname)
        write(gen_file, "")
        write(gen_file, "========================================")
        write(gen_file, "Contrail Configuration API Specification")
        write(gen_file, "========================================")
        write(gen_file, "")
        write(gen_file, "")
        write(gen_file, "Configuration objects in Contrail are created either by")
        write(gen_file, "")
        write(gen_file, "  * User (via GUI, api or an external program) for abstractions visible to End Users.")
        write(gen_file, "  * System (contrail processes like contrail-schema, contrail-svc-monitor etc.)")
        write(gen_file, "    to aid in functioning of all the control components/services.")
        write(gen_file, "")
        write(gen_file, "So for e.g. an end-user might create a virtual-network, but the system creates a")
        write(gen_file, "routing-instance and route-target for that virtual-network.")

        used_schemas = set()
        user_obj_types = set([])
        system_obj_types = set([])
        for res_type, dmo in openapi_dict['x-datamodel']['objects'].items():
            if not dmo.get('parents'):
                user_obj_types.add(res_type)
                continue
            for parent_link in dmo['parents'].values():
                if parent_link['is_derived']:
                    system_obj_types.add(res_type)
                else:
                    user_obj_types.add(res_type)
        write(gen_file, "")
        write(gen_file, 'User created object types')
        write(gen_file, '=========================')
        write(gen_file, '.. hlist::')
        write(gen_file, '    :columns: 3')
        write(gen_file, '')

        user_obj_types_str = '    * ' + '\n    * '.join([':ref:`%s <%s-label>`' %(uot, uot) for uot in user_obj_types])
        write(gen_file, user_obj_types_str)
        #for user_obj_type in user_obj_types:
        #    write(gen_file, "     :ref:`%s <%s-label>`" %(user_obj_type, user_obj_type))
        #write(gen_file, "    "+ ', '.join(list(user_obj_types)))
        write(gen_file, "")
        write(gen_file, 'System created object types')
        write(gen_file, '===========================')
        write(gen_file, '.. hlist::')
        write(gen_file, '    :columns: 3')
        write(gen_file, '')
        sys_obj_types_str = '    * ' + '\n    * '.join([':ref:`%s <%s-label>`' %(sot, sot) for sot in system_obj_types])
        write(gen_file, sys_obj_types_str)
        #for sys_obj_type in system_obj_types:
        #    write(gen_file, "    * "+sys_obj_type)
        #write(gen_file, "    "+ ', '.join(list(system_obj_types)))

        write(gen_file, "")
        write(gen_file, 'Type specific REST API and data model')
        write(gen_file, '======================================')
        for resource_type, datamodel_object in openapi_dict['x-datamodel']['objects'].items():
            write(gen_file, '.. _%s-label: ' %(resource_type))
            write(gen_file, '')
            write(gen_file, resource_type)
            write(gen_file, '-'*len(resource_type))
            write(gen_file, 'Data Model')
            write(gen_file, '^^^^^^^^^^')
            write(gen_file, '*Description*')
            for desc_line in datamodel_object.get('description', '').split('\n'):
                write(gen_file, '        ' + desc_line)
            else:
                write(gen_file, '')
            if not datamodel_object.get('parents'):
                write(gen_file, '*Parents*: None')
            else:
                write(gen_file, '*Parents*: %s' %(', '.join(
                    [':ref:`%s <%s-label>`' %(p, p) for p in datamodel_object.get('parents', [])])))
            write(gen_file, '')
            write(gen_file, '*Children*')
            children = [res_type for res_type, dmo in openapi_dict['x-datamodel']['objects'].items()
                                           if resource_type in dmo.get('parents', [])]
            if not children:
                write(gen_file, '        None')
            else:
                write(gen_file, '        ' + ', '.join(
                    [':ref:`%s <%s-label>`' %(c, c) for c in children]))

            write(gen_file, '')
            write(gen_file, '*Properties*')
            write(gen_file, '')
            if datamodel_object.get('properties'):
                write(gen_file, '.. csv-table::')
                write(gen_file, '    :header: "Name", "Description", "Required", "Type", "Operations", "Created By"')
                write(gen_file, '')
            else:
                write(gen_file, '')
            for prop_name, prop_info in datamodel_object.get('properties', {}).items():
                prop_desc = csv_scrub(prop_info.get('description', 'None').replace('\n', ' '))
                prop_reqd = prop_info['required']
                if '$ref' in prop_info:
                    prop_type = prop_info['$ref'].split('/')[-1]
                    prop_type_str = ':ref:`%s <%s-label>`' %(prop_type, prop_type)
                    used_schemas.add(prop_type)
                else:
                    prop_type_str = prop_info['type']
                prop_oper = prop_info.get('operations')
                prop_by = prop_info.get('created-by')
                write(gen_file, '        %s, %s, %s, %s, %s, %s' %(
                    prop_name, prop_desc, prop_reqd, prop_type_str, prop_oper, prop_by))
                write(gen_file, '')
            write(gen_file, '')
            write(gen_file, '*References*')
            write(gen_file, '')
            if datamodel_object.get('references'):
                write(gen_file, '.. csv-table::')
                write(gen_file, '    :header: "To", "Description", "Required", "Type", "Operations", "Created By"')
                write(gen_file, '')
            else:
                write(gen_file, '    None')
            for ref_name, ref_info in datamodel_object.get('references', {}).items():
                ref_desc = csv_scrub(ref_info.get('description', 'None').replace('\n', ' '))
                ref_reqd = ref_info.get('required')
                ref_attr = ref_info.get('attr', {}).get('$ref', 'None').split('/')[-1]
                ref_oper = ref_info.get('operations')
                ref_by = ref_info.get('created-by')
                write(gen_file, '    :ref:%s `%s-label`, %s, %s, %s, %s, %s' %(
                    ref_name, ref_name, ref_desc, ref_reqd, ref_attr, ref_oper, ref_by))
                if ref_attr:
                    used_schemas.add(ref_attr)
                write(gen_file, '')
            write(gen_file, '')
            write(gen_file, '*Back References*')
            write(gen_file, '')
            backrefs = set([])
            for res_type, dmo in openapi_dict['x-datamodel']['objects'].items():
                if res_type == resource_type:
                    continue
                if resource_type in dmo.get('references', {}):
                    backrefs.add(res_type)
            if backrefs:
                write(gen_file, '    ' + ', '.join([':ref:%s `%s-label`'%(b, b) for b in backrefs]))
            else:
                write(gen_file, '    None')
            write(gen_file, '')
            write(gen_file, 'REST API')
            write(gen_file, '^^^^^^^^')
            for path_name, path_info in openapi_dict['paths'].items():
                if resource_type not in path_name:
                    continue

                for oper_name, oper_info in path_info.items():
                    write(gen_file, '**%s**'%(oper_info['summary']))
                    write(gen_file, "")
                    write(gen_file, "%s %s" %(oper_name.upper(), path_name))
                    write(gen_file, "")
                    write(gen_file, "*Parameters*")
                    write(gen_file, "")
                    write(gen_file, ".. csv-table::")
                    write(gen_file, '    :header: "Type", "Name", "Description", "Schema", "Default"')
                    write(gen_file, "")

                    for param_info in oper_info['parameters']:
                        type_str = '**%s**' %(param_info['in'])
                        if param_info['in'].lower() == 'path':
                            presence_str = '*required*'
                        elif (param_info.get('required') and
                              param_info['required']):
                            presence_str = '*required*'
                        else:
                            presence_str = '*optional*'
                        if 'name' in param_info:
                            name_str = '**%s**' %(param_info['name'])
                            desc_str = csv_scrub(param_info.get('description', ''))
                            if param_info['in'].lower() == 'query':
                                schema_str = get_schema_str(param_info)
                                schema_names = get_schema_name(param_info)
                                default_str = param_info.get('default', '')
                            else:
                                schema_str = get_schema_str(param_info.get('schema'))
                                schema_names = get_schema_name(param_info.get('schema'))
                                default_str = ''
                            write(gen_file, "    %s, %s %s, %s, %s, %s" %(
                                type_str, name_str, presence_str,
                                desc_str, schema_str, default_str))
                            used_schemas |= set(schema_names)
                        else: # anonymous parameter
                            schema_type = param_info['schema']['$ref'].split(
                                              '/')[-1]
                            oap_props, oap_required = get_props_and_allof(
                                openapi_dict['definitions'][schema_type])
                            for oap_name, oap_info in oap_props.items():
                                name_str = '**%s**' %(oap_name)
                                if oap_name in oap_required:
                                    presence_str = '*required*'
                                else:
                                    presence_str = '*optional*'
                                desc_str = csv_scrub(oap_info.get('description', ''))
                                schema_str = get_schema_str(oap_info)
                                schema_names = get_schema_name(oap_info)
                                default_str = ''
                                write(gen_file, "    %s, %s %s, %s, %s, %s" %(
                                    type_str, name_str, presence_str, desc_str,
                                    schema_str, default_str))
                                used_schemas |= set(schema_names)
                    write(gen_file, "")

                    # end all params on oper

                    write(gen_file, "*Responses*")
                    write(gen_file, "")
                    write(gen_file, ".. csv-table::")
                    write(gen_file, '    :header: "HTTP Code", "Description", "Schema"')
                    write(gen_file, "")
                    for rsp_code, rsp_info in oper_info['responses'].items():
                        code_str = "**%s**" %(rsp_code)
                        desc_str = csv_scrub(rsp_info.get('description', ''))
                        schema_str = get_schema_str(rsp_info.get('schema'))
                        schema_names = get_schema_name(rsp_info.get('schema'))
                        write(gen_file, "    %s, %s, %s" %(
                            code_str, desc_str, schema_str))
                        used_schemas |= set(schema_names)
                    # end all responses on oper
                    write(gen_file, '')
                # end for all oper on path
                write(gen_file, '')
            # end for all paths on resource_type
            write(gen_file, '')
        # end for all resource types

        write(gen_file, "")
        write(gen_file, 'Generic REST API')
        write(gen_file, '================')
        datamodel_object_types = openapi_dict['x-datamodel']['objects'].keys()
        generic_path_items = dict((pname, pinfo) for pname, pinfo in openapi_dict['paths'].items()
                                                 if not any([x in pname for x in datamodel_object_types]))
        for path_name, path_info in generic_path_items.items():
            for oper_name, oper_info in path_info.items():
                write(gen_file, '**%s**'%(oper_info['summary']))
                write(gen_file, "")
                write(gen_file, "%s %s" %(oper_name.upper(), path_name))
                write(gen_file, "")
                write(gen_file, "*Parameters*")
                write(gen_file, "")
                write(gen_file, ".. csv-table::")
                write(gen_file, '    :header: "Type", "Name", "Description", "Schema", "Default"')
                write(gen_file, "")

                for param_info in oper_info['parameters']:
                    type_str = '**%s**' %(param_info['in'])
                    if param_info['in'].lower() == 'path':
                        presence_str = '*required*'
                    elif (param_info.get('required') and
                          param_info['required']):
                        presence_str = '*required*'
                    else:
                        presence_str = '*optional*'
                    if 'name' in param_info:
                        name_str = '**%s**' %(param_info['name'])
                        desc_str = csv_scrub(param_info.get('description', ''))
                        if param_info['in'].lower() == 'query':
                            schema_str = get_schema_str(param_info)
                            schema_names = get_schema_name(param_info)
                            default_str = param_info.get('default', '')
                        else:
                            schema_str = get_schema_str(param_info.get('schema'))
                            schema_names = get_schema_name(param_info.get('schema'))
                            default_str = ''
                        write(gen_file, "    %s, %s %s, %s, %s, %s" %(
                            type_str, name_str, presence_str,
                            desc_str, schema_str, default_str))
                        used_schemas |= set(schema_names)
                    else: # anonymous parameter
                        schema_type = param_info['schema']['$ref'].split(
                                          '/')[-1]
                        oap_props, oap_required = get_props_and_allof(
                            openapi_dict['definitions'][schema_type])
                        for oap_name, oap_info in oap_props.items():
                            name_str = '**%s**' %(oap_name)
                            if oap_name in oap_required:
                                presence_str = '*required*'
                            else:
                                presence_str = '*optional*'
                            desc_str = csv_scrub(oap_info.get('description', ''))
                            schema_str = get_schema_str(oap_info)
                            schema_names = get_schema_name(oap_info)
                            default_str = ''
                            write(gen_file, "    %s, %s %s, %s, %s, %s" %(
                                type_str, name_str, presence_str, desc_str,
                                schema_str, default_str))
                            used_schemas |= set(schema_names)
                write(gen_file, "")

                # end all params on oper

                write(gen_file, "*Responses*")
                write(gen_file, "")
                write(gen_file, ".. csv-table::")
                write(gen_file, '    :header: "HTTP Code", "Description", "Schema"')
                write(gen_file, "")
                for rsp_code, rsp_info in oper_info['responses'].items():
                    code_str = "**%s**" %(rsp_code)
                    desc_str = csv_scrub(rsp_info.get('description', ''))
                    schema_str = get_schema_str(rsp_info.get('schema'))
                    schema_names = get_schema_name(rsp_info.get('schema'))
                    write(gen_file, "    %s, %s, %s" %(
                        code_str, desc_str, schema_str))
                    used_schemas |= set(schema_names)
                # end all responses on oper
                write(gen_file, '')
            # end for all oper on path
            write(gen_file, '')

        write(gen_file, "")
        write(gen_file, "Definitions")
        write(gen_file, "===========")
        write(gen_file, "")
        def generate_def(defn_name, defn_info):
            now_used_schemas = set()
            oap_props, oap_required = get_props_and_allof(defn_info)
            if not oap_props:
                return now_used_schemas
            write(gen_file, '.. _%s-label: ' %(defn_name))
            write(gen_file, "")
            write(gen_file, defn_name)
            write(gen_file, "-"*len(defn_name))
            write(gen_file, "")
            write(gen_file, ".. csv-table::")
            write(gen_file, '    :header: "Name", "Description", "Schema"')
            write(gen_file, "")
            for oap_name, oap_info in oap_props.items():
                name_str = '**%s**' %(oap_name)
                if oap_name in oap_required:
                    presence_str = '*required*'
                else:
                    presence_str = '*optional*'
                desc_str = csv_scrub(oap_info.get('description', ''))
                schema_str = get_schema_str(oap_info)
                schema_names = get_schema_name(oap_info)
                write(gen_file, "    %s %s, %s, %s" %(
                    name_str, presence_str, desc_str, schema_str))
                now_used_schemas |= set(schema_names)
            write(gen_file, "")
            return now_used_schemas - used_schemas
        deferred_schemas = set()
        for defn_name, defn_info in openapi_dict['definitions'].items():
            if (defn_name in used_schemas or
                defn_name.endswith('ReadDetail') or defn_name.endswith('ReadAll')):
                deferred_schemas |= generate_def(defn_name, defn_info)
        while True:
            if not deferred_schemas:
                break
            schema_name = deferred_schemas.pop()
            used_schemas.add(schema_name)
            deferred_schemas |= generate_def(schema_name, openapi_dict['definitions'][schema_name])

        # end for all definitions
        write(gen_file, "")
    # end _generate_docs_sphinx
# end class IFMapApiGenerator

